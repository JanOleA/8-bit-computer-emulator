char = 60000                 ; temp for printing
dividend = 60001             ; dividend for the divide routine
divisor = 60002              ; divisor for the divide routine
quotient = 60003             ; quotient of the division
remainder = 60004            ; remainder in the division
check_value = 60005          ; value to check if it is prime
loop_index = 60006           ; index of the loop
half_check = 60007           ; half of the value we are checking
pow2 = 60008                 ; helper for divide routine
num_digits = 60009           ; number of digits stacked for display

start:
  ; print initial prime 2
  LDI 2
  STA .check_value
  JSR display_number
  JSR newline

  LDI 3             ; start checking from 3
  STA .check_value

main_loop:
  ; stop when we reach above 300
  LDA .check_value
  CPI 301
  JPC done

  JSR check_prime
  ; if not prime, check_prime returns without printing
  LDA .check_value
  ADI 2            ; check only odds
  STA .check_value
  JMP main_loop

done:
  HLT


; divide: divides .dividend by .divisor
; Returns quotient in A and .quotient, remainder in .remainder
divide:
  LDI 0
  STA .quotient     ; initialize quotient as 0
  LDI 1
  STA .pow2         ; initialize pow2 as 1
inc_b:              ; increase the divisor by multiplying by 2 while <= dividend
  LDA .divisor      ; load divisor into A
  LSA               ; left shift (i.e. mult. by 2)
  JPC div_loop      ; if carry, done increasing
  CMP .dividend
  JPZ pass          ; if equal, keep it
  JPC div_loop      ; if now > dividend, done inc
pass:
  STA .divisor      ; store divisor*2 as new divisor
  LDA .pow2
  LSA               ; pow2 *= 2
  STA .pow2
  JMP inc_b         ; go back
div_loop:
  LDA .pow2
  CPI 0             ; compare pow2 to zero
  JPZ div_end       ; if zero, done divide
  LDA .dividend
  CMP .divisor      ; compare dividend to divisor
  JPC a_geq_b       ; if dividend >= divisor
  JMP continue      ; else
a_geq_b:
  LDA .quotient
  ADD .pow2         
  STA .quotient     ; add pow2 to the quotient
  LDA .dividend
  SUB .divisor
  STA .dividend     ; subtract divisor from dividend
continue:
  LDA .divisor
  RSA
  STA .divisor      ; divisor /= 2
  LDA .pow2
  RSA
  STA .pow2         ; pow2 /= 2
  JMP div_loop
div_end:
  LDA .dividend
  STA .remainder
  LDA .quotient
  RET


; check_prime: prints .check_value if prime
check_prime:
  LDA .check_value
  RSA               ; divide by 2
  STA .half_check
  LDI 3
  STA .loop_index
prime_loop:
  LDA .loop_index
  CMP .half_check
  JPC prime
  STA .divisor
  LDA .check_value
  STA .dividend
  JSR divide
  LDA .remainder
  CPI 0
  JPZ not_prime
  LDA .loop_index
  ADI 2            ; next odd divisor
  STA .loop_index
  JMP prime_loop
not_prime:
  RET
prime:
  LDA .check_value
  STA .char
  JSR display_number
  JSR newline
  RET


; display_number: print .arg1 or .char value as decimal using monitor
; On entry: value in .char or .arg1 (we'll use .char)
display_number:
  ; move .char into .arg1
  LDA .char
  STA .arg1
  LDI 0
  STA .num_digits
calc_next_val:
  LDI 10
  STA .arg2
  ; set up divide: dividend=.arg1, divisor=.arg2
  LDA .arg1
  STA .dividend
  LDA .arg2
  STA .divisor
  JSR divide        ; quotient in A, remainder in .remainder
  STA .arg1         ; next value to divide
  LDA .remainder
  ADI 48            ; convert to ascii
  PHA               ; push digit
  LDA .num_digits
  ADI 1
  STA .num_digits
  LDA .arg1
  CPI 0
  JPZ print_stack
  JMP calc_next_val
print_stack:
  PLA
  STA .char
  JSR write_char
  LDA .num_digits
  SUI 1
  STA .num_digits
  JPZ end_dispnum
  JMP print_stack
end_dispnum:
  RET


; write_char: write .char to monitor (LDD; DIC read; DIC enable; DIC 0)
write_char:
  LDD .char
  DIC 0
  DIC 64
  DIC 192
  DIC 0
  RET


; newline via monitor
newline:
  DIS 32
  DIC 0
  DIC 128
  DIC 0
  RET

