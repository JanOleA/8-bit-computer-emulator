;! name: DIVIDE
;! entry: divide
;! deps:
;! abi: os
;! bss: auto
;! align: 100

divide:             ; documented divide using BSS locals
  ; Locals layout:
  ;   .bss       = dividend (mutable)
  ;   .bss + 1   = divisor (mutable)
  ;   .bss + 2   = pow2 (scaling factor)
  ;   .bss + 3   = quotient

  ; Copy inputs into locals
  LDA .arg1
  STA .bss          ; dividend
  LDA .arg2
  STA .bss + 1      ; divisor

  ; Initialize
  LDI 0
  STA .bss + 3      ; quotient = 0
  LDI 1
  STA .bss + 2      ; pow2 = 1

  ; Handle divisor == 0 → quotient=0, remainder=dividend
  LDA .bss + 1
  CPI 0
  JPZ div_zero

inc_b:
  ; Double divisor until it would exceed dividend
  LDA .bss + 1      ; A = divisor
  LSA               ; A = divisor * 2
  JPC div_loop      ; overflow → stop increasing
  CMP .bss          ; compare with dividend
  JPZ pass          ; if equal, still accept doubling once
  JPC div_loop      ; if > dividend, stop increasing
pass:
  STA .bss + 1      ; divisor = divisor * 2
  LDA .bss + 2
  LSA
  STA .bss + 2      ; pow2 *= 2
  JMP inc_b

div_loop:
  ; While pow2 > 0
  LDA .bss + 2
  CPI 0
  JPZ div_end
  ; If dividend >= divisor: quotient += pow2; dividend -= divisor
  LDA .bss
  CMP .bss + 1
  JPC a_geq_b
  JMP continue
a_geq_b:
  LDA .bss + 3
  ADD .bss + 2
  STA .bss + 3      ; quotient += pow2
  LDA .bss
  SUB .bss + 1
  STA .bss          ; dividend -= divisor
continue:
  ; Shift down and continue
  LDA .bss + 1
  RSA
  STA .bss + 1      ; divisor >>= 1
  LDA .bss + 2
  RSA
  STA .bss + 2      ; pow2 >>= 1
  JMP div_loop

div_end:
  ; remainder in dividend, quotient in A
  LDA .bss
  STA .res2
  LDA .bss + 3
  RET

div_zero:
  LDA .bss
  STA .res2
  LDI 0
  RET
