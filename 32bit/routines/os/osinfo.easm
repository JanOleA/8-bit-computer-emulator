;! name: OSINFO
;! entry: osinfo
;! deps: newline, print, printez, display_number, divide, write_char
;! abi: os
;! bss: auto
;! align: 4

.linechar = "-"
.version =                 "EShell (ESH) 25.9.3a"
.bits_avail_text_1 =       "AReg size       : "
.bits_avail_text_2 =       " bits"
.memory_available_text =   "Memory available: "
.memory_available_text_2 = " k words"
.memory_available_text_3 = "                  ("
.memory_available_text_4 = " bits/word)"
.installed_progs_text =    "Installed routines/programs: "
.installed_progs_text_2 =  "Words used for programs (k): "
.bss_text =                "Words reserved for BSS (k) : "
.data_text =               "Words reserved for data (k): "

.help_text = "Type HELP for a list of commands"
.list_text = "Type LIST for a list of all installed"
.list_text_2 = "                  routines/programs"

osinfo:
  ; print OS info
  JSR write_40_dash
  LDI .version
  JSR print_newline
  LDI .bits_avail_text_1
  JSR print_no_newline
  LDA .bits_avail
  PHA
  JSR @display_number
  LDI .bits_avail_text_2
  JSR print_newline
  LDI .memory_available_text
  JSR print_no_newline
  LDI 0
  SUI 1
  STA .arg1
  LDI 1000
  STA .arg2
  JSR @divide
  LDA .res1
  PHA
  JSR @display_number
  LDI .memory_available_text_2
  JSR print_newline
  LDI .memory_available_text_3
  JSR print_no_newline
  LDA .bits_avail
  PHA
  JSR @display_number
  LDI .memory_available_text_4
  JSR print_newline
  JSR get_num_progs
  LDI .installed_progs_text
  JSR print_no_newline
  LDA .bss + 2
  PHA
  JSR @display_number
  JSR @newline
  LDI .installed_progs_text_2
  JSR print_no_newline
  LDA .bss + 3                    ; words used for programs
  STA .bss + 10
  LDA .bss + 7
  STA .bss + 11
  JSR print_decimal
  JSR @newline
  LDI .bss_text
  JSR print_no_newline
  LDA .bss + 4                    ; words used for bss
  STA .bss + 10
  LDA .bss + 8
  STA .bss + 11
  JSR print_decimal
  JSR @newline
  LDI .data_text
  JSR print_no_newline
  LDA .bss + 5                    ; words used for data
  STA .bss + 10
  LDA .bss + 9
  STA .bss + 11
  JSR print_decimal
  JSR @newline
  LDI .help_text
  JSR print_newline
  LDI .list_text
  JSR print_newline
  LDI .list_text_2
  JSR print_newline
  JSR write_40_dash
  JSR @newline
  RET

print_decimal:  ; -- print a decimal number, bss + 10 = before decimal, bss + 11 = after decimal --
  LDA .bss + 10
  PHA
  JSR @display_number
  LDI 46
  JSR @write_char
  LDA .bss + 11
  PHA
  JSR @display_number
  RET

get_num_progs:
  LDI .prog_table
  ADI 16
  LAP
  STA .bss + 10 ; base of first program
  LDI 0
  STA .bss + 1  ; word step from .prog_table
  STA .bss + 2  ; program count
  STA .bss + 3  ; size of the final program in the table
  STA .bss + 4  ; words used for BSS
  STA .bss + 5  ; words used for data
  STA .bss + 7  ; decimal for words used for programs
  STA .bss + 8  ; decimal for words used for BSS
  STA .bss + 9  ; decimal for words used for data
  STA .bss + 11 ; base of final program
check_prog_loop:
  LDI .prog_table
  ADD .bss + 1
  LAP                 ; get the first word of the name, if it's not null, continue
  CPI 0
  JPZ get_n_progs_end ; if it is null, end
  LDA .bss + 2
  ADI 1
  STA .bss + 2        ; increment program count by 1

  LDA .bss + 1
  ADI 16              ; increment word step by 16
  STA .bss + 1
  ADI .prog_table
  LAP                 ; get base for this program
  STA .bss + 11

  LDA .bss + 1
  ADI 1               ; increment word step by 17 (17 total)
  STA .bss + 1
  ADI .prog_table
  LAP                 ; get words used for this program
  STA .bss + 3        ; store it

  LDA .bss + 1
  ADI 2               ; increment word step by 2 (19 total)
  STA .bss + 1
  ADI .prog_table
  LAP                 ; get BSS words reserved for this program
  ADD .bss + 4        ; add current sum
  STA .bss + 4        ; store it again

  LDA .bss + 1
  ADI 2              ; increment word step by 2 (21 total)
  STA .bss + 1
  ADI .prog_table
  LAP                 ; get data words reserved for this program
  ADD .bss + 5        ; add current sum
  ADI 8               ; add 8 to compensate for the average gap between data regions
  STA .bss + 5        ; store it again

  LDA .bss + 1
  ADI 1               ; increment word step by 1 (22 total)
  STA .bss + 1

  JMP check_prog_loop
get_n_progs_end:
  LDA .bss + 11       ; base of final program
  ADD .bss + 3        ; size of final program
  SUB .bss + 10       ; base of first program
  STA .arg1
  LDI 1000
  STA .arg2
  JSR @divide
  STA .bss + 3        ; result from divide is stored in A reg
  LDA .res2           ; get remainder
  STA .arg1
  LDI 10
  STA .arg2
  JSR @divide
  STA .bss + 7        ; store value after decimal

  LDA .bss + 4
  STA .arg1
  LDI 1000
  STA .arg2
  JSR @divide 
  STA .bss + 4        ; result from divide is stored in A reg
  LDA .res2           ; get remainder
  STA .arg1
  LDI 10
  STA .arg2
  JSR @divide
  STA .bss + 8        ; store value after decimal

  LDA .bss + 5
  STA .arg1
  LDI 1000
  STA .arg2
  JSR @divide
  STA .bss + 5        ; result from divide is stored in A reg
  LDA .res2           ; get remainder
  STA .arg1
  LDI 10
  STA .arg2
  JSR @divide
  STA .bss + 9        ; store value after decimal

  RET

; -- print helpers, null terminated. Pointer to text must be in A register --
write_40_dash:
  LDI 0
  STA .bss
write_char_loop:
  LDA .linechar
  JSR @write_char
  LDA .bss
  ADI 1
  STA .bss
  CPI 40
  JPC end_wc_loop
  JMP write_char_loop
end_wc_loop:
  JSR @newline
  RET

print_newline:
  PHA
  JSR @printez
  RET

print_no_newline:
  PHA
  LDI 1
  PHA
  LDI 0
  PHA
  JSR @print
  RET