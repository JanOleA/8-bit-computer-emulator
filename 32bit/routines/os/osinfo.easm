;! name: OSINFO
;! entry: osinfo
;! deps: newline, print, printez, printf, display_number, divide, write_char, multiply, q7_8_from_ratio
;! abi: args sysinfo
;! bss: auto
;! align: 1
;! callable: yes

.linechar = "-"
.version =                 "EShell (ESH) 25.9.0a5 - 2025-09-28"
.sys_bits_avail_text_1 =       "AReg size       : %u bits"
.memory_available_text =   "Memory available: %f kwords"
.memory_available_text_2 = "                  (%u bits/word)"
.installed_progs_text =    "Installed routines/programs: "
.installed_progs_text_2 =  "Words used for programs (k): %f"
.bss_text =                "Words reserved for BSS (k) : %f"
.data_text =               "Words reserved for data (k): %f"
.end_data_text =           "Reserved memory: [0, %u)"

.help_text = "Type HELP for a list of commands"
.list_text = "Type LIST for a list of all installed"
.list_text_2 = "                  routines/programs"

osinfo:
  ; print OS info
  JSR write_40_dash
  LDI .version
  JSR print_newline
  LDI .sys_bits_avail_text_1
  PHA
  LDI .__sys_bits_avail
  PHA
  JSR @printf
  LDI 2
  PHA
  LDA .__sys_bits_avail
  SUI 2
  PHA
  JSR @pow
  PHA                     ; now have 2^(bits_per_word - 2) in A reg
  LDI 250                 ; construct fraction of (2^(bits_per_word - 2)) / 250, i.e. 2^(bits_per_word)/1000
  PHA
  JSR @q7_8_from_ratio
  STA .__res1
  LDI .memory_available_text
  PHA
  LDI .__res1
  PHA
  JSR @printf
  LDI .memory_available_text_2
  PHA
  LDI .__sys_bits_avail
  PHA
  JSR @printf
  JSR get_num_progs
  LDI .installed_progs_text
  JSR print_no_newline
  LDA .bss + 2
  JSR @display_number
  JSR @newline
  LDI .installed_progs_text_2
  PHA
  LDI .bss + 7                   ; words used for programs
  PHA
  JSR @printf
  LDI .bss_text
  PHA
  LDI .bss + 4                   ; words used for BSS
  PHA
  JSR @printf
  LDI .data_text
  PHA
  LDI .bss + 5                   ; words used for data
  PHA
  JSR @printf
  LDI .end_data_text
  PHA
  LDA .bss + 14
  STA .__sys_reserved_region_end
  LDI .bss + 14                   ; end of data region (pointer)
  PHA
  JSR @printf
  JSR write_40_dash
  LDI .help_text
  JSR print_newline
  LDI .list_text
  JSR print_newline
  LDI .list_text_2
  JSR print_newline
  JSR write_40_dash
  JSR @newline
  RET

print_decimal:  ; -- print a decimal number, bss + 10 = before decimal, bss + 11 = after decimal --
  LDA .bss + 10
  JSR @display_number
  LDI 46
  JSR @write_char
  ; Ensure two digits after the decimal point (value is expected 0..99)
  LDA .bss + 11
  CPI 10
  JPC pd_two_digits    ; if >= 10, no leading zero needed
  LDI 48               ; '0'
  JSR @write_char
pd_two_digits:
  LDA .bss + 11
  JSR @display_number
  RET

get_num_progs:
  LDI .__sys_prog_table
  ADI 16
  LAP
  STA .bss + 10 ; base of first program
  LDI 0
  STA .bss + 1  ; word step from .__sys_prog_table
  STA .bss + 2  ; program count
  STA .bss + 3  ; size of the current program's code in the table (and final program after the loop)
  STA .bss + 4  ; total words used for BSS
  STA .bss + 5  ; total words used for data
  STA .bss + 7  ; words used for programs
  STA .bss + 8 ; data used for current program (and final program after the loop)
  STA .bss + 9 ; start of data region
  STA .bss + 12 ; base of current program (and final program after the loop)
  STA .bss + 13 ; data base of current program (and final program after the loop)
  STA .bss + 14 ; end of final program's data region (ceil to nearest 10)
check_prog_loop:
  LDI .__sys_prog_table
  ADD .bss + 1
  LAP                 ; get the first word of the name, if it's not null, continue
  CPI 0
  JPZ get_n_progs_end ; if it is null, end
  LDA .bss + 2
  ADI 1
  STA .bss + 2        ; increment program count by 1

  LDA .bss + 1
  ADI 16              ; increment word step by 16
  STA .bss + 1
  ADI .__sys_prog_table
  LAP                 ; get base for this program
  STA .bss + 12

  LDA .bss + 1
  ADI 1               ; increment word step by 17 (17 total)
  STA .bss + 1
  ADI .__sys_prog_table
  LAP                 ; get words used for this program
  STA .bss + 3        ; store it

  LDA .bss + 1
  ADI 2               ; increment word step by 2 (19 total)
  STA .bss + 1
  ADI .__sys_prog_table
  LAP                 ; get BSS words reserved for this program
  ADD .bss + 4        ; add current sum
  STA .bss + 4        ; store it again

  LDA .bss + 1
  ADI 1               ; increment word step by 1 (20 total)
  STA .bss + 1
  ADI .__sys_prog_table
  LAP                 ; get data base for this program (not used)
  STA .bss + 13       ; store it

  LDA .bss + 1
  ADI 1               ; increment word step by 1 (21 total)
  STA .bss + 1
  ADI .__sys_prog_table
  LAP                 ; get data words reserved for this program
  STA .bss + 8       ; store it temporarily

  CPI 0
  JPZ skip_data_end
  LDA .bss + 9       ; start of data region
  CPI 1
  JPC skip_set_data_start
  LDA .bss + 13       ; data base of this program
  STA .bss + 9       ; set start of data region
skip_set_data_start:
  LDA .bss + 8       ; data words reserved for this program
  ADD .bss + 13       ; add data base to get end of data region
  STA .bss + 14       ; store it
skip_data_end:

  LDA .bss + 1
  ADI 11              ; increment word step by 11 (32 total)
  STA .bss + 1

  JMP check_prog_loop
get_n_progs_end:
  LDA .bss + 12       ; base of final program
  ADD .bss + 3        ; size of final program
  SUB .bss + 10       ; base of first program
  PHA                 ; push words used for programs onto stack
  LDI 1000
  PHA                 ; push 1000 onto stack
  JSR @q7_8_from_ratio
  STA .bss + 7        ; store value after decimal

  LDA .bss + 4
  PHA                 ; push words used for BSS onto stack
  LDI 1000
  PHA                 ; push 1000 onto stack
  JSR @q7_8_from_ratio
  STA .bss + 4        ; result from decimal construction is stored in A reg

  LDA .bss + 14       ; end of data region
  SUB .bss + 9       ; - (start of data region) = get total data words used
  PHA                 ; push words used for data onto stack
  LDI 1000
  PHA                 ; push 1000 onto stack
  JSR @q7_8_from_ratio
  STA .bss + 5        ; result from decimal construction is stored in A reg

  LDA .bss + 14
  ADI 1               ; add one for safety margin
  STA .__arg1
  LDI 10
  STA .__arg2
  JSR @divide
  PHA
  LDI 10
  PHA
  JSR @multiply
  ADI 10              ; ceil to nearest 10
  STA .bss + 14

  RET

; -- print helpers, null terminated. Pointer to text must be in A register --
write_40_dash:
  LDI 0
  STA .bss
write_char_loop:
  LDA .linechar
  JSR @write_char
  LDA .bss
  ADI 1
  STA .bss
  CPI 40
  JPC end_wc_loop
  JMP write_char_loop
end_wc_loop:
  JSR @newline
  RET

print_newline:
  PHA
  JSR @printez
  RET

print_no_newline:
  PHA
  LDI 1
  PHA
  LDI 0
  PHA
  JSR @print
  RET