;! name: HELP
;! entry: help
;! deps: echon, parse_number, newline, write_char, buffer_to_separator, divide, display_number
;! abi: os
;! bss: auto
;! align: 20

; Items, separated by backslash ("\\"). Kept in a single auto-data string.
.separator = "\\"
.help_items = "LIST: show all installed commands\\HELP page: show this help at page\\ECHO arg: print argument to terminal\\CLS: clear the screen\\PEEK addr: print mem[addr]\\POKE addr val: store val at addr\\PRIMES: print primes up to 300\\PUZZLE: Matt Parker 19 puzzle\\ESH: simple command prompt\\DUMP addr len: print decimal words\\HEXDUMP addr len: print hex words\\CALC a op b: compute result\\MEMEDIT addr: begin editing mem@addr\\FILLMEM start num val: fill memory\\CPYMEM src dst len: copy memory\\   mem[src:src+len] > mem[dst:dst+len]\\FIBO: print fibonacci values"

; BSS locals
per_page = .bss

help:
  ; Determine total items by scanning tokens separated by '\\'
  LDI 14
  STA .per_page       ; per-page
  LDI .help_items
  STA .bss + 4        ; scan_ptr
  LDI 0
  STA .bss + 5        ; total_items = 0
hp_cnt_lp:
  ; Tokenize at current pointer
  LDA .separator
  STA .arg2
  LDA .bss + 4
  STA .arg1
  JSR @buffer_to_separator
  ; len -> bss+6
  LDA .res2
  STA .bss + 6
  ; Advance pointer by len
  LDA .bss + 4
  ADD .bss + 6
  STA .bss + 4
  ; If length > 0, count item
  LDA .bss + 6
  CPI 0
  JPZ hp_cnt_check_end
  LDA .bss + 5
  ADI 1
  STA .bss + 5
hp_cnt_check_end:
  ; Probe current char (separator or 0)
  LDA .bss + 4
  PHA
  LAS
  CMP .separator
  JPZ hp_cnt_skipsep
  CPI 0
  JPZ hp_cnt_done
  ; Unexpected non-sep char (shouldn't happen), continue
  JMP hp_cnt_lp
hp_cnt_skipsep:
  LDA .bss + 4
  ADI 1
  STA .bss + 4
  JMP hp_cnt_lp
hp_cnt_done:
  ; Compute total_pages = ceil(total_items / per_page) with divide
  ; store total_items temporarily in .bss+5
  LDA .bss + 5
  STA .arg1
  LDA .per_page
  STA .arg2
  JSR @divide
  STA .bss + 7        ; quotient
  LDA .res2
  CPI 0
  JPZ hp_pages_noinc
  LDA .bss + 7
  ADI 1
  STA .bss + 7
hp_pages_noinc:
  ; Ensure at least 1 page
  LDA .bss + 7
  CPI 1
  JPC hp_pages_have
  LDI 1
  STA .bss + 7
hp_pages_have:

  ; Default page = 1
  LDI 1
  STA .res1           ; page = 1
  ; argc = [argv_base]
  LDI .argv_base
  PHA
  LAS
  CPI 0                   ; if argc == 0, keep default page = 1
  JPZ hp_after_parse
  ; else parse first argument as page: arg_ptr = [argv_base+1]
  LDI .argv_base
  ADI 1
  PHA
  LAS
  STA .arg1           ; arg1 = pointer to page string
  JSR @parse_number
hp_after_parse:
  ; clamp page to [1, pages(.bss + 7)]
  LDA .res1
  CPI 1
  JPC hp_have_min
  LDI 1
  STA .res1
hp_have_min:
  ; if page > total_pages, set to total_pages
  LDA .bss + 7
  CMP .res1           ; C=1 if total_pages >= page
  JPC hp_page_ok
  LDA .bss + 7
  STA .res1
hp_page_ok:
  ; Print header: page/total_pages using display_number
  LDA .res1
  STA .arg1
  JSR @display_number
  ; slash
  LDI 47
  STA .char
  JSR @write_char
  ; total pages
  LDA .bss + 7
  STA .arg1
  JSR @display_number
  JSR @newline

  ; skip = (page-1)*per_page into .bss+1
  LDA .res1
  SUI 1
  STA .num_digits     ; reuse num_digits as loops remaining of pages-1
  LDI 0
  STA .bss + 1        ; skip = 0
hp_skip_lp:
  LDA .num_digits
  CPI 0
  JPZ hp_skip_done
  LDA .bss + 1
  ADD .per_page
  STA .bss + 1
  LDA .num_digits
  SUI 1
  STA .num_digits
  JMP hp_skip_lp
hp_skip_done:
  ; printed = 0 (store in bss+2). Reset token scan pointer to start.
  LDI 0
  STA .bss + 2
  LDI .help_items
  STA .bss + 4
  ; Iterate tokens; skip first 'skip', print up to 'per_page'
hp_iter:
  ; Stop if printed >= per_page
  LDA .bss + 2
  CMP .per_page
  JPC hp_done
  ; Tokenize current
  LDA .separator
  STA .arg2
  LDA .bss + 4
  STA .arg1
  JSR @buffer_to_separator
  ; len -> bss+6
  LDA .res2
  STA .bss + 6
  ; If end-of-string and len==0 -> done
  LDA .bss + 6
  CPI 0
  JPZ hp_check_end
  ; If still skipping, decrement and advance without printing
  LDA .bss + 1
  CPI 0
  JPZ hp_print
  SUI 1
  STA .bss + 1
  JMP hp_advance
hp_print:
  ; Print buffered token
  LDA .res1
  STA .arg1
  LDI 0
  STA .num_digits
  LDI 0
  STA .arg2
  JSR @echon
  ; printed++
  LDA .bss + 2
  ADI 1
  STA .bss + 2
hp_advance:
  ; Advance scan pointer by len and optional separator
  LDA .bss + 4
  ADD .bss + 6
  STA .bss + 4
  LDA .bss + 4
  PHA
  LAS
  CMP .separator
  JPZ hp_skipsep2
  CPI 0
  JPZ hp_done
  JMP hp_iter
hp_skipsep2:
  LDA .bss + 4
  ADI 1
  STA .bss + 4
  JMP hp_iter
hp_check_end:
  ; len==0; if at end (null), stop; else if separator (empty token), skip sep and continue
  LDA .bss + 4
  PHA
  LAS
  CPI 0
  JPZ hp_done
  CMP .separator
  JPZ hp_skipsep2
  JMP hp_done
hp_done:
  RET
