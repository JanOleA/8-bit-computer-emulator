;! name: ESH
;! entry: start
;! deps: osinfo, newline, write_char, toggle_display_enable, get_program_address, buffer_to_separator, print, printez
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes

; BSS layout (relative to auto `.bss` base)
;   +0    key value / status flag
;   +1    key ready flag
;   +2    history head index
;   +3    history entry count
;   +4    history cursor position
;   +5    history multiplication scratch
;   +6    history multiplication accumulator
;   +7..+1606 history buffer (40 entries Ã— 40 chars)
;   +1607 sentinel workspace for res_bss
;   +1608 pointer to argument start in input buffer
;   +1609 command scanning pointer
;   +1610 history write pointer
;   +1611 generic copy source pointer
;   +1612 generic copy destination pointer
;   +1613 argv slot pointer
;   +1614 argv char buffer pointer
;   +1615 argv input pointer
;   +1616 argv scanning pointer
;   +1617 temporary counter
;   +1618 temporary char store
;   +1619 cached program entry address

hist_entry_len = 40   ; max characters per history entry and input line
hist_max    = 40      ; max number of history entries

.cmd_error_message = "Unknown command: "
.cmd_error_message_2 = "Type HELP for a list of commands"
.cmd_error_message_3 = "Program not callable from shell"

start:
  JSR @osinfo
  ; initialize shell state
  LDI 0
  STA .__cmd_len
  STA .__cmd_ready
  STA .bss + 2
  STA .bss + 3
  STA .bss + 4
  LDI .__input_buf
  STA .__input_ptr
  JSR print_prompt
  JMP main_loop

; --- Main loop ---
main_loop:
  JSR check_input
  LDA .bss + 1
  CPI 0
  JPZ no_input
  LDA .__no_input
  CPI 1
  JPZ main_loop
  LDA .bss
  CPI 31
  JPZ handle_enter
  CPI 32
  JPZ handle_enter
  CPI 42
  JPZ handle_hist_up
  CPI 53
  JPZ handle_hist_down
  CPI 43
  JPZ handle_backspace
  CPI 52
  JPZ handle_left
  LDA .__ascii_start
  ADD .bss
  LAP
  STA .char
  JSR @write_char
  ; buffer char
  LDA .__input_ptr
  PHA
  LDA .char
  SAS
  ; advance ptr and len with clamps
  LDA .__input_ptr
  ADI 1
  STA .__input_ptr
  ; clamp __input_ptr to __input_buf + hist_entry_len
  CPI .__input_buf + .hist_entry_len
  JPZ clamp_ptr
  JMP after_ptr
clamp_ptr:
  LDA .__input_ptr
  SUI 1
  STA .__input_ptr
after_ptr:
  LDA .__cmd_len
  ADI 1
  STA .__cmd_len
  ; clamp __cmd_len to hist_entry_len
  CPI .hist_entry_len
  JPZ clamp_len
  JMP after_len
clamp_len:
  LDA .__cmd_len
  SUI 1
  STA .__cmd_len
after_len:
  LDI 1
  STA .__no_input
  JMP main_loop

no_input:
  LDI 0
  STA .__no_input
  JMP main_loop

handle_left:
  LDI 1
  STA .__no_input
  JMP main_loop

check_input:
  LDA .__inc_random_seed
  CPI 0
  JPZ pass_increase
  LDA .__random_seed
  ADI 1
  STA .__random_seed
pass_increase:
  KEI
  PHA
  CPI 128
  JPC input_entered     ; handle input if keyboard register is >= 128, since the 128 bit is signal bit
  PLA
  LDI 0
  STA .bss + 1
  RET
input_entered:
  PLA
  SUI 128
  OUT
  STA .bss
  LDI 1
  STA .bss + 1
  LDI 0
  STA .__inc_random_seed
  RET

handle_hist_up:
  JSR history_up
  LDI 1
  STA .__no_input
  JMP main_loop

handle_hist_down:
  JSR history_down
  LDI 1
  STA .__no_input
  JMP main_loop

handle_backspace:
  LDA .__input_ptr
  CPI .__input_buf
  JPZ hb_done
  LDA .__input_ptr
  SUI 1
  STA .__input_ptr
  LDA .__input_ptr
  PHA
  LDI 0
  SAS
  LDA .__cmd_len
  CPI 0
  JPZ hb_after_len
  SUI 1
  STA .__cmd_len
hb_after_len:
  JSR cursor_left
  LDI 32
  JSR @write_char
  JSR cursor_left
hb_done:
  LDI 1
  STA .__no_input
  JMP main_loop

handle_enter:
  ; terminate buffer, set ready
  LDA .__input_ptr
  PHA
  LDI 0
  SAS
  LDI 1
  STA .__cmd_ready
  ; newline
  JSR enter
  ; run command
  JSR run_command
  ; save to history
  JSR save_history
  ; reset buffer
  LDI .__input_buf
  STA .__input_ptr
  LDI 0
  STA .__cmd_len
  ; prompt
  JSR print_prompt
  LDI 1
  STA .__no_input
  JMP main_loop

; --- UI helpers ---

; -- print helpers, null terminated. Pointer to text must be in A register --
print_newline:
  PHA
  JSR @printez
  RET

print_no_newline:
  PHA
  LDI 1
  PHA
  LDI 0
  PHA
  JSR @print
  RET

ret_home:
  JSR @newline
  DIS 24
  JSR @toggle_display_enable
  RET

print_prompt:
  LDI 62
  JSR @write_char
  LDI 32
  JSR @write_char
  RET

cursor_left:
  DIS 18
  JSR @toggle_display_enable
  RET

enter:
  JSR @newline
  RET

clear_line:
  JSR ret_home
  LDI 40
  STA .__num_digits
cl_loop:
  LDI 32
  JSR @write_char
  LDA .__num_digits
  SUI 1
  STA .__num_digits
  JNZ cl_loop
cl_done:
  JSR ret_home
  JSR print_prompt
  RET

; --- Command parsing ---
run_command:
  LDI .__input_buf
  STA .bss + 1609
  JSR skip_spaces
  JSR dispatch_program
  RET

skip_spaces:
  LPA .bss + 1609
  CPI 32
  JPZ sksp_inc
  RET
sksp_inc:
  LDA .bss + 1609
  ADI 1
  STA .bss + 1609
  JMP skip_spaces

dispatch_program:
  LDA .bss + 1609
  PHA
  LDI 32
  PHA                       ; buffer to first space
  JSR @buffer_to_separator
  PLA                       ; buffer pointer
  STA .__res1
  PLA                       ; length
  STA .__res2
  PLA                       ; end_on_null                   ; not needed here
  LDA .__res2
  CPI 0
  JPZ dp_nomatch            ; jump to no match if buffer returns empty string (0 length)
  LDI .__input_buf
  ADD .__res2                 ; add length of command to input buffer to get to start of arguments
  STA .bss + 1608           ; store memory location for start of argument buffer
  LDA .__res1
  STA .__arg1
  JSR @get_program_address
  STA .bss + 1619           ; store resolved program entry
  CPI 0
  JPZ dp_nomatch
  LDA .__res2
  CPI 0
  JPZ dp_not_callable
  
dp_match:
  LDA .bss + 1608
  STA .bss + 1609
  JSR skip_spaces
  LDA .bss + 1609
  STA .bss + 1615
  JSR build_argv
  LDI .__argv_base
  STA .__arg1
  LDI .__argv_buf
  STA .__arg2
  LDA .bss + 1619
  STA 19997
  JSR #19996
  LDA 19999
  STA 19997 ; reset the call stub entry to the initial (shell)
  LDI 1
  STA .bss
  RET
dp_nomatch:
  LDA .__cmd_len
  CPI 0
  JPZ err_help
  LDI .cmd_error_message
  JSR print_no_newline
  LDI .__input_buf
  JSR print_newline
  JMP err_help
dp_not_callable:
  LDI .cmd_error_message_3
  JSR print_newline
err_help:
  LDI .cmd_error_message_2
  JSR print_newline
  LDI 0
  STA .bss
  RET

; Build argc/argv from the raw argument string referenced by .bss + 1615
build_argv:
  LDI .__argv_base
  PHA
  LDI 0
  SAS
  LDI .__argv_base
  ADI 1
  STA .bss + 1613
  LDI .__argv_buf
  STA .bss + 1614
  LDA .bss + 1615
  STA .bss + 1616
ba_next_token:
  LPA .bss + 1616
  CPI 32
  JPZ ba_skip_whitespace
  CPI 0
  JPZ ba_done
  JMP ba_start
ba_skip_whitespace:
  LDA .bss + 1616
  ADI 1
  STA .bss + 1616
  JMP ba_next_token
ba_start:
  LDA .__argv_base
  CPI 8
  JPZ ba_done
  LDA .bss + 1613
  PHA
  LDA .bss + 1614
  SAS
  LDA .bss + 1614
  STA .bss + 1612
ba_copy:
  LPA .bss + 1616
  CPI 0
  JPZ ba_term
  CPI 32
  JPZ ba_term
  STA .bss + 1618
  LDA .bss + 1612
  PHA
  LDA .bss + 1618
  SAS
  LDA .bss + 1616
  ADI 1
  STA .bss + 1616
  LDA .bss + 1612
  ADI 1
  STA .bss + 1612
  JMP ba_copy
ba_term:
  LDA .bss + 1612
  PHA
  LDI 0
  SAS
  LDA .bss + 1612
  ADI 1
  STA .bss + 1614
  LDA .__argv_base
  ADI 1
  STA .bss + 1617
  LDI .__argv_base
  PHA
  LDA .bss + 1617
  SAS
  LDA .bss + 1613
  ADI 1
  STA .bss + 1613
  JMP ba_next_token
ba_done:
  RET

; --- History ---
save_history:
  LDA .__cmd_len
  CPI 0
  JPZ sh_done
  ; compute dest = hist_base + .bss + 2*80
  LDA .bss + 2
  STA .bss + 5
  LDA .bss + 5
  LSA
  LSA
  LSA
  LSA
  STA .bss + 6
  LDA .bss + 5
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  ADD .bss + 6
  STA .bss + 6
  LDI .bss + 7
  ADD .bss + 6
  STA .bss + 1610
  LDI .__input_buf
  STA .bss + 1611
  LDI 0
  STA .bss + 1617
sh_copy:
  LDA .bss + 1617
  CPI 80
  JPZ sh_pad_done
  LPA .bss + 1611
  STA .bss + 1618
  CPI 0
  JPZ sh_pad
  LDA .bss + 1610
  PHA
  LDA .bss + 1618
  SAS
  LDA .bss + 1611
  ADI 1
  STA .bss + 1611
  LDA .bss + 1610
  ADI 1
  STA .bss + 1610
  LDA .bss + 1617
  ADI 1
  STA .bss + 1617
  JMP sh_copy
sh_pad:
  LDA .bss + 1610
  PHA
  LDI 0
  SAS
  LDA .bss + 1610
  ADI 1
  STA .bss + 1610
  LDA .bss + 1617
  ADI 1
  STA .bss + 1617
  JMP sh_copy
sh_pad_done:
  LDA .bss + 2
  ADI 1
  CPI .hist_max
  JPZ sh_head_wrap
  STA .bss + 2
  JMP sh_head_set
sh_head_wrap:
  LDI 0
  STA .bss + 2
sh_head_set:
  LDA .bss + 3
  ADI 1
  CPI .hist_max
  JPZ sh_cnt_cap
  STA .bss + 3
  JMP sh_cnt_done
sh_cnt_cap:
  LDI .hist_max
  STA .bss + 3
sh_cnt_done:
  LDI 0
  STA .bss + 4
sh_done:
  RET

history_load_current:
  JSR clear_line
  LDI .__input_buf
  STA .__input_ptr
  LDI 0
  STA .__cmd_len
  LDA .bss + 4
  CPI 0
  JPZ hlc_blank
  LDA .bss + 2
  CMP .bss + 4
  JPC hlc_nowrap
  LDA .bss + 2
  ADI .hist_max
  SUB .bss + 4
  STA .bss + 1617
  JMP hlc_idx_ready
hlc_nowrap:
  LDA .bss + 2
  SUB .bss + 4
  STA .bss + 1617
hlc_idx_ready:
  LDA .bss + 1617
  LSA
  LSA
  LSA
  LSA
  STA .bss + 6
  LDA .bss + 1617
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  ADD .bss + 6
  STA .bss + 6
  LDI .bss + 7
  ADD .bss + 6
  STA .bss + 1611
  LDI 0
  STA .bss + 1617
hlc_copy:
  LDA .bss + 1617
  CPI .hist_entry_len
  JPZ hlc_done
  LPA .bss + 1611
  STA .char
  CPI 0
  JPZ hlc_done
  JSR @write_char
  LDA .__input_ptr
  PHA
  LDA .char
  SAS
  LDA .bss + 1611
  ADI 1
  STA .bss + 1611
  LDA .__input_ptr
  ADI 1
  STA .__input_ptr
  LDA .__cmd_len
  ADI 1
  STA .__cmd_len
  LDA .bss + 1617
  ADI 1
  STA .bss + 1617
  JMP hlc_copy
hlc_done:
  LDA .__input_ptr
  PHA
  LDI 0
  SAS
  RET
hlc_blank:
  LDA .__input_ptr
  PHA
  LDI 0
  SAS
  RET

history_up:
  LDA .bss + 3
  CPI 0
  JPZ hup_done
  LDA .bss + 4
  CMP .bss + 3
  JPC hup_load
  LDA .bss + 4
  ADI 1
  STA .bss + 4
hup_load:
  JSR history_load_current
hup_done:
  RET

history_down:
  LDA .bss + 4
  CPI 0
  JPZ hdn_load
  LDA .bss + 4
  SUI 1
  STA .bss + 4
hdn_load:
  JSR history_load_current
  RET

res_bss:
  LDI 0
  STA .bss + 1607
