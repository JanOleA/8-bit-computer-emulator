;! name: ESH
;! entry: start
;! deps: osinfo, newline, write_char, echon, toggle_display_enable, get_program_address, buffer_to_separator
;! abi: os
;! bss: auto
;! align: 4

; Input buffering and history
; bss + 0 = keyboard input value
; bss + 1 = keyboard input entered
; bss + 2 = hist_head
; bss + 3 = hist_count
; bss + 4 = hist_pos
; bss + 5 = hist_tmp1
; bss + 6 = hist_tmp2
; bss + 7 = hist_start
; bss + 7 .. bss + 1607 = hist_buffer
; bss + 1608 = characters in command
hist_entry_len = 40   ; max characters per history entry and input line
hist_max    = 40      ; max number of history entries

.cmd_error_message = "Unknown command: "
.cmd_error_message_2 = "Type HELP for a list of commands"

start:
  JSR @osinfo
  ; initialize shell state
  LDI 0
  STA .cmd_len
  STA .cmd_ready
  STA .bss + 2
  STA .bss + 3
  STA .bss + 4
  LDI .input_buf
  STA .input_ptr
  JSR print_prompt
  JMP main_loop

; --- Main loop ---
main_loop:
  JSR check_input
  LDA .bss + 1
  CPI 0
  JPZ no_input
  LDA .no_input
  CPI 1
  JPZ main_loop
  LDA .bss
  CPI 31
  JPZ handle_enter
  CPI 32
  JPZ handle_enter
  CPI 42
  JPZ handle_hist_up
  CPI 53
  JPZ handle_hist_down
  CPI 43
  JPZ handle_backspace
  CPI 52
  JPZ handle_left
  LDA .ascii_start
  ADD .bss
  PHA
  LAS
  STA .char
  JSR @write_char
  ; buffer char
  LDA .input_ptr
  PHA
  LDA .char
  SAS
  ; advance ptr and len with clamps
  LDA .input_ptr
  ADI 1
  STA .input_ptr
  ; clamp input_ptr to input_buf + hist_entry_len
  CPI .input_buf + .hist_entry_len
  JPZ clamp_ptr
  JMP after_ptr
clamp_ptr:
  LDA .input_ptr
  SUI 1
  STA .input_ptr
after_ptr:
  LDA .cmd_len
  ADI 1
  STA .cmd_len
  ; clamp cmd_len to hist_entry_len
  CPI .hist_entry_len
  JPZ clamp_len
  JMP after_len
clamp_len:
  LDA .cmd_len
  SUI 1
  STA .cmd_len
after_len:
  LDI 1
  STA .no_input
  JMP main_loop

no_input:
  LDI 0
  STA .no_input
  JMP main_loop

handle_left:
  LDI 1
  STA .no_input
  JMP main_loop

check_input:
  LDA .inc_random_seed
  CPI 0
  JPZ pass_increase
  LDA .random_seed
  ADI 1
  STA .random_seed
pass_increase:
  KEI
  PHA
  CPI 128
  JPC input_entered     ; handle input if keyboard register is >= 128, since the 128 bit is signal bit
  PLA
  LDI 0
  STA .bss + 1
  RET
input_entered:
  PLA
  SUI 128
  OUT
  STA .bss
  LDI 1
  STA .bss + 1
  LDI 0
  STA .inc_random_seed
  RET

handle_hist_up:
  JSR history_up
  LDI 1
  STA .no_input
  JMP main_loop

handle_hist_down:
  JSR history_down
  LDI 1
  STA .no_input
  JMP main_loop

handle_backspace:
  LDA .input_ptr
  CPI .input_buf
  JPZ hb_done
  LDA .input_ptr
  SUI 1
  STA .input_ptr
  LDA .input_ptr
  PHA
  LDI 0
  SAS
  LDA .cmd_len
  CPI 0
  JPZ hb_after_len
  SUI 1
  STA .cmd_len
hb_after_len:
  JSR cursor_left
  LDI 32
  STA .char
  JSR @write_char
  JSR cursor_left
hb_done:
  LDI 1
  STA .no_input
  JMP main_loop

handle_enter:
  ; terminate buffer, set ready
  LDA .input_ptr
  PHA
  LDI 0
  SAS
  LDI 1
  STA .cmd_ready
  ; newline
  JSR enter
  ; run command
  JSR run_command
  ; save to history
  JSR save_history
  ; reset buffer
  LDI .input_buf
  STA .input_ptr
  LDI 0
  STA .cmd_len
  ; prompt
  JSR print_prompt
  LDI 1
  STA .no_input
  JMP main_loop

; --- UI helpers ---

; -- print helpers, null terminated. Pointer to text must be in A register --
print_newline:
  STA .arg1
  LDI 0
  STA .num_digits
  STA .arg2
  JSR @echon
  RET

print_no_newline:
  STA .arg1
  LDI 0
  STA .num_digits
  LDI 1
  STA .arg2
  JSR @echon
  RET

ret_home:
  JSR @newline
  DIS 24
  JSR @toggle_display_enable
  RET

print_prompt:
  LDI 62
  STA .char
  JSR @write_char
  LDI 32
  STA .char
  JSR @write_char
  RET

cursor_left:
  DIS 18
  JSR @toggle_display_enable
  RET

enter:
  JSR @newline
  RET

clear_line:
  JSR ret_home
  LDI 40
  STA .num_digits
cl_loop:
  LDI 32
  STA .char
  JSR @write_char
  LDA .num_digits
  SUI 1
  STA .num_digits
  JNZ cl_loop
cl_done:
  JSR ret_home
  JSR print_prompt
  RET

; --- Command parsing ---
run_command:
  LDI .input_buf
  STA .arg1
  JSR skip_spaces
  JSR dispatch_program
  RET

skip_spaces:
  LDA .arg1
  PHA
  LAS
  CPI 32
  JPZ sksp_inc
  RET
sksp_inc:
  LDA .arg1
  ADI 1
  STA .arg1
  JMP skip_spaces

dispatch_program:
  LDI 32
  STA .arg2                 ; buffer to first space
  JSR @buffer_to_separator
  LDA .res2
  CPI 0
  JPZ dp_nomatch            ; jump to no match if buffer returns empty string (0 length)
  LDI .input_buf
  ADD .res2                 ; add length of command to input buffer to get to start of arguments
  STA .bss + 1608           ; store memory location for start of argument buffer
  LDA .res1
  STA .arg1
  JSR @get_program_address
  STA .work4                ; store address for program in work4
  CPI 0
  JPZ dp_nomatch
  
dp_match:
  LDA .bss + 1608
  STA .arg1
  JSR skip_spaces
  JSR build_argv
  LDI .argv_base
  STA .arg1
  LDI .argv_buf
  STA .arg2
  LDA .work4
  STA 19997
  JSR #19996
  LDA 19999
  STA 19997 ; reset the call stub entry to the initial (shell)
  LDI 1
  STA .bss
  RET
dp_nomatch:
  LDA .cmd_len
  CPI 0
  JPZ err_help
  LDI .cmd_error_message
  JSR print_no_newline
  LDI .input_buf
  JSR print_newline
err_help:
  LDI .cmd_error_message_2
  JSR print_newline
  LDI 0
  STA .bss
  RET

; Build argc/argv from the raw argument string at .arg1
build_argv:
  LDI .argv_base
  PHA
  LDI 0
  SAS
  LDI .argv_base
  ADI 1
  STA .work1
  LDI .argv_buf
  STA .work2
  LDA .arg1
  STA .work3
ba_next_token:
  LDA .work3
  PHA
  LAS
  CPI 32
  JPZ ba_skip1
  CPI 0
  JPZ ba_done
  JMP ba_start
ba_skip1:
  LDA .work3
  ADI 1
  STA .work3
  JMP ba_next_token
ba_start:
  LDA .argv_base
  CPI 8
  JPZ ba_done
  LDA .work1
  PHA
  LDA .work2
  SAS
ba_copy:
  LDA .work3
  PHA
  LAS
  CPI 0
  JPZ ba_term
  CPI 32
  JPZ ba_term
  STA .char
  LDA .work2
  PHA
  LDA .char
  SAS
  LDA .work3
  ADI 1
  STA .work3
  LDA .work2
  ADI 1
  STA .work2
  JMP ba_copy
ba_term:
  LDA .work2
  PHA
  LDI 0
  SAS
  LDA .work2
  ADI 1
  STA .work2
  LDA .argv_base
  ADI 1
  STA .num_digits
  LDI .argv_base
  PHA
  LDA .num_digits
  SAS
  LDA .work1
  ADI 1
  STA .work1
  JMP ba_next_token
ba_done:
  RET

; --- History ---
save_history:
  LDA .cmd_len
  CPI 0
  JPZ sh_done
  ; compute dest = hist_base + hist_head*80
  LDA .bss + 2
  STA .bss + 5
  LDA .bss + 5
  LSA
  LSA
  LSA
  LSA
  STA .bss + 6
  LDA .bss + 5
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  ADD .bss + 6
  STA .bss + 1
  LDI .bss + 7
  ADD .bss + 1
  STA .arg2
  LDI .input_buf
  STA .arg1
  LDI 0
  STA .num_digits
sh_copy:
  LDA .num_digits
  CPI 80
  JPZ sh_pad_done
  LDA .arg1
  PHA
  LAS
  STA .char
  CPI 0
  JPZ sh_pad
  LDA .arg2
  PHA
  LDA .char
  SAS
  LDA .arg1
  ADI 1
  STA .arg1
  LDA .arg2
  ADI 1
  STA .arg2
  LDA .num_digits
  ADI 1
  STA .num_digits
  JMP sh_copy
sh_pad:
  LDA .arg2
  PHA
  LDI 0
  SAS
  LDA .arg2
  ADI 1
  STA .arg2
  LDA .num_digits
  ADI 1
  STA .num_digits
  JMP sh_copy
sh_pad_done:
  LDA .bss + 2
  ADI 1
  CPI .hist_max
  JPZ sh_head_wrap
  STA .bss + 2
  JMP sh_head_set
sh_head_wrap:
  LDI 0
  STA .bss + 2
sh_head_set:
  LDA .bss + 3
  ADI 1
  CPI .hist_max
  JPZ sh_cnt_cap
  STA .bss + 3
  JMP sh_cnt_done
sh_cnt_cap:
  LDI .hist_max
  STA .bss + 3
sh_cnt_done:
  LDI 0
  STA .bss + 4
sh_done:
  RET

history_load_current:
  JSR clear_line
  LDI .input_buf
  STA .input_ptr
  LDI 0
  STA .cmd_len
  LDA .bss + 4
  CPI 0
  JPZ hlc_blank
  LDA .bss + 2
  CMP .bss + 4
  JPC hlc_nowrap
  LDA .bss + 2
  ADI .hist_max
  SUB .bss + 4
  STA .bss
  JMP hlc_idx_ready
hlc_nowrap:
  LDA .bss + 2
  SUB .bss + 4
  STA .bss
hlc_idx_ready:
  LDA .bss
  LSA
  LSA
  LSA
  LSA
  STA .bss + 5
  LDA .bss
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  ADD .bss + 5
  STA .bss + 1
  LDI .bss + 7
  ADD .bss + 1
  STA .arg1
  LDI 0
  STA .num_digits
hlc_copy:
  LDA .num_digits
  CPI .hist_entry_len
  JPZ hlc_done
  LDA .arg1
  PHA
  LAS
  STA .char
  CPI 0
  JPZ hlc_done
  JSR @write_char
  LDA .input_ptr
  PHA
  LDA .char
  SAS
  LDA .arg1
  ADI 1
  STA .arg1
  LDA .input_ptr
  ADI 1
  STA .input_ptr
  LDA .cmd_len
  ADI 1
  STA .cmd_len
  LDA .num_digits
  ADI 1
  STA .num_digits
  JMP hlc_copy
hlc_done:
  LDA .input_ptr
  PHA
  LDI 0
  SAS
  RET
hlc_blank:
  LDA .input_ptr
  PHA
  LDI 0
  SAS
  RET

history_up:
  LDA .bss + 3
  CPI 0
  JPZ hup_done
  LDA .bss + 4
  CMP .bss + 3
  JPC hup_load
  LDA .bss + 4
  ADI 1
  STA .bss + 4
hup_load:
  JSR history_load_current
hup_done:
  RET

history_down:
  LDA .bss + 4
  CPI 0
  JPZ hdn_load
  LDA .bss + 4
  SUI 1
  STA .bss + 4
hdn_load:
  JSR history_load_current
  RET

res_bss:
  LDI 0
  STA .bss + 1607
