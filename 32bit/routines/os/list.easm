;! name: LIST
;! entry: list_commands
;! deps: write_char, newline, print
;! abi: all
;! bss: auto
;! align: 4
;! callable: yes

; Program table row layout (32 words total):
;   0..15  NAME (uppercase, null padded)
;   16     BASE address
;   17     LENGTH (code words)
;   18     BSS_BASE (0 if none)
;   19     BSS_SIZE
;   20     DATA_BASE (0 if none)
;   21     DATA_SIZE
;   22..31 FLAGS (flag0 = callable-from-shell, others reserved)
; Stride = 32 words

.more_text = "              --- more ---"

list_commands:
  LDI .prog_table
  STA .bss + 1
  LDI 0
  STA .bss + 2
  STA .bss
lc_next:
  LPA .bss + 1                ; load mem[mem[.bss + 1]] into A
  CPI 0
  JPZ lc_end
  LDA .bss + 1
  STA .res2
  LDI 0
  STA .num_digits
lc_printchar:
  LDA .num_digits
  CPI 16
  JPZ lc_pad
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ lc_pad
  JSR @write_char
  LDA .res2
  ADI 1
  STA .res2
  LDA .num_digits
  ADI 1
  STA .num_digits
  JMP lc_printchar
lc_pad:
  LDA .num_digits
  CPI 18
  JPZ lc_aftercol
  LDI 32
  JSR @write_char
  LDA .num_digits
  ADI 1
  STA .num_digits
  JMP lc_pad
lc_aftercol:
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  CPI 2
  JPZ lc_newline
  JMP lc_advance
lc_newline:
  JSR @newline
  LDA .bss
  ADI 1
  STA .bss
  CPI 19
  JPZ lc_more
  LDI 0
  STA .bss + 2
  JMP lc_advance
lc_more:
  ; print "--- more ---"
  LDI .more_text
  PHA
  LDI 1
  PHA       ; skip newline
  LDI 0
  PHA       ; max length = 0 (unbounded)
  JSR @print
  ; wait for any key
lc_wait_key:
  KEI
  PHA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  CPI 1
  JPZ lc_key_ok
  PLA
  JMP lc_wait_key
lc_key_ok:
  PLA
  JSR @newline
  LDI 0
  STA .bss
  STA .bss + 2
lc_advance:
  LDA .bss + 1
  ADI 32                ; forward by 32 (new program table row stride)
  STA .bss + 1
  JMP lc_next
lc_end:
  LDA .bss + 2
  CPI 1
  JPZ end_newline
  RET
end_newline:
  JSR @newline
  RET
