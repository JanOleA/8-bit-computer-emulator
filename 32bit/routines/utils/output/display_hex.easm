;! name: DISPHEX
;! entry: display_hex
;! deps: divide, write_char
;! abi: all
;! bss: auto
;! align: 1

; -- Prints a number in hexadecimal (uppercase) --
; Input: Stack Pointer - 2: argument: value to print (unsigned)

; BSS locals
; .bss      = working value (dividend)
; .bss + 1  = digit count
; .bss + 2  = input value, to return it to the A register at the end

display_hex:
  PLA                     ; get return address from stack
  MOVAB                   ; move return address to B for now

  PLA                     ; Argument. Copy input value into local working storage
  STA .bss
  STA .bss + 2

  MOVBA                   ; move return address back to A
  PHA                     ; push it back to stack

  ; Handle zero specially -> print '0'
  LDA .bss
  CPI 0
  JPZ dn_zero
  ; Reset digit count
  LDI 0
  STA .bss + 1
dn_loop:
  ; Divide working value by 16, push remainder as ASCII hex
  LDA .bss
  CPI 0
  JPZ dn_print
  ; prepare args for divide
  LDA .bss
  STA .arg1
  LDI 16
  STA .arg2
  ; divide by 16: returns A=quotient, .res2=remainder
  JSR @divide
  STA .bss            ; carry quotient forward
  LDA .res2
  CPI 10
  JPC dn_hex_alpha    ; if remainder >= 10 â†’ A-F
  ADI 48              ; '0'..'9'
  PHA                 ; push ASCII digit
  JMP dn_pushed
dn_hex_alpha:
  SUI 10
  ADI 65              ; 'A'..'F'
  PHA
dn_pushed:
  ; increment digit count
  LDA .bss + 1
  ADI 1
  STA .bss + 1
  JMP dn_loop

dn_print:
  ; Pop and print digits
  ; Save digit count to .res3 before we start decrementing it
  LDA .bss + 1
  STA .res3
  LDA .bss + 1
  CPI 0
  JPZ dn_done
dn_pop:
  PLA
  JSR @write_char
  LDA .bss + 1
  SUI 1
  STA .bss + 1
  JPZ dn_done
  JMP dn_pop

dn_zero:
  LDI 48
  JSR @write_char
  ; one character printed
  LDI 1
  STA .res3
  LDA .bss + 2
  RET

dn_done:
  LDA .bss + 2
  RET
