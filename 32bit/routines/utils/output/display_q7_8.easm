;! name: DISPQ78
;! entry: display_q7_8
;! deps: display_number, pow, write_char
;! abi: sysinfo args
;! bss: auto
;! align: 1

; Prints a signed Q7.8 fixed-point value as decimal: "[-]I.FFF"
; - Input: A = Q7.8 value (two's complement). Word size from .__sys_bits_avail
; - Output: prints integer part, '.', and 3 fractional digits (rounded to nearest),
;   returns total characters printed in .__res3. A restored to original input.

orig_val    = .bss + 0
work_val    = .bss + 1
sign_mask   = .bss + 2
chars       = .bss + 3
ipart       = .bss + 4
frac        = .bss + 5
digit       = .bss + 6
tmp         = .bss + 7
cnt         = .bss + 8
d1          = .bss + 9
d2          = .bss + 10
d3          = .bss + 11
d4          = .bss + 12

display_q7_8:
  ; save original
  STA .orig_val
  STA .work_val

  ; compute sign mask = 2^(bits-1)
  LDI 2
  PHA
  LDA .__sys_bits_avail
  SUI 1
  PHA
  JSR @pow
  STA .sign_mask

  ; init char count
  LDI 0
  STA .chars

  ; check sign
  LDA .work_val
  CMP .sign_mask
  JPC q78_neg
  JMP q78_abs_done
q78_neg:
  ; print '-'
  LDI 45
  JSR @write_char
  LDI 1
  STA .chars
  ; negate to get magnitude
  LDI 0
  SUB .work_val
  STA .work_val
q78_abs_done:

  ; integer part: ipart = work_val >> 8 (magnitude, so logical shift OK)
  LDA .work_val
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .ipart

  ; fractional remainder: frac = work_val - (ipart << 8)
  ; tmp = ipart << 8
  LDA .ipart
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  STA .tmp
  LDA .work_val
  SUB .tmp
  STA .frac

  ; compute 4 fractional digits by repeated scaling (store first 4 digits)
  ; d1, d2, d3, d4
  LDI 0
  STA .d1
  STA .d2
  STA .d3
  STA .d4
  LDI 4
  STA .cnt
q78_frac_prep_loop:
  LDA .cnt
  CPI 0
  JPZ q78_round
  ; frac *= 10 → (frac<<3) + (frac<<1)
  LDA .frac
  LSA
  STA .tmp          ; tmp = frac<<1
  LDA .frac
  LSA
  LSA
  LSA               ; A = frac<<3
  ADD .tmp          ; A = frac*10
  STA .frac
  ; digit = frac >> 8
  LDA .frac
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .digit
  ; frac -= digit << 8
  LDA .digit
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  STA .tmp
  LDA .frac
  SUB .tmp
  STA .frac
  ; store digit into d1..d4
  LDA .cnt
  CPI 4
  JPZ q78_store_d1
  CPI 3
  JPZ q78_store_d2
  CPI 2
  JPZ q78_store_d3
  ; else cnt==1 → d4
  LDA .digit
  STA .d4
  JMP q78_prep_next
q78_store_d1:
  LDA .digit
  STA .d1
  JMP q78_prep_next
q78_store_d2:
  LDA .digit
  STA .d2
  JMP q78_prep_next
q78_store_d3:
  LDA .digit
  STA .d3
q78_prep_next:
  LDA .cnt
  SUI 1
  STA .cnt
  JMP q78_frac_prep_loop

q78_round:
  ; Round to nearest based on d4 (away from zero on ties handled by >=5)
  LDA .d4
  CPI 5
  JPC q78_do_round
  JMP q78_after_round
q78_do_round:
  ; increment d3, cascade carries to d2, d1, and ipart
  LDA .d3
  ADI 1
  CPI 10
  JPC q78_carry_d3
  STA .d3
  JMP q78_after_round
q78_carry_d3:
  LDI 0
  STA .d3
  LDA .d2
  ADI 1
  CPI 10
  JPC q78_carry_d2
  STA .d2
  JMP q78_after_round
q78_carry_d2:
  LDI 0
  STA .d2
  LDA .d1
  ADI 1
  CPI 10
  JPC q78_carry_d1
  STA .d1
  JMP q78_after_round
q78_carry_d1:
  LDI 0
  STA .d1
  LDA .ipart
  ADI 1
  STA .ipart

q78_after_round:
  ; Now print integer part (unsigned)
  LDA .ipart
  JSR @display_number
  LDA .__res3
  ADD .chars
  STA .chars

  ; print '.'
  LDI 46
  JSR @write_char
  LDA .chars
  ADI 1
  STA .chars

  ; print d1, d2, d3
  LDA .d1
  ADI 48
  JSR @write_char
  LDA .chars
  ADI 1
  STA .chars

  LDA .d2
  ADI 48
  JSR @write_char
  LDA .chars
  ADI 1
  STA .chars

  LDA .d3
  ADI 48
  JSR @write_char
  LDA .chars
  ADI 1
  STA .chars

q78_done:
  ; return count in .__res3, restore A
  LDA .chars
  STA .__res3
  LDA .orig_val
  RET
