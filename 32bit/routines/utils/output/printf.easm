;! name: PRINTF
;! entry: printf
;! deps: printez, display_int, display_hex, write_char
;! abi: 
;! bss: auto
;! align: 1

; --- Print a formatted null-terminated string to standard output, followed by a newline ---

; Call signature: print(SP - 3, SP - 2) = print(string_pointer, args_pointer)
; Inputs:
;   Stack Pointer - 3 = pointer to string to be formatted
;   Stack Pointer - 2 = pointer to arguments
; Returns: A = number of characters printed

; example args pointer = some_mem_location
; mem[some_mem_location + 0] = first argument
; mem[some_mem_location + 1] = second argument
; mem[some_mem_location + 2] = third argument
; ...
; e.g. a string and an integer:
; mem[some_mem_location + 0] = pointer to string -> to pass to printez, LDA some_mem_location + 0; PHA; JSR @write_string
; mem[some_mem_location + 1] = integer value
; ...

; -- format specifiers supported:
; %d - signed decimal integer
; %u - unsigned decimal integer
; %x - hexadecimal integer
; %s - string
; %% - literal percent sign

string_pointer  = .bss + 0
args_pointer    = .bss + 1
chars_printed   = .bss + 2
tmp             = .bss + 3

printf:
  PLA                       ; get return address from stack
  MOVAB                     ; move return address to B for now

  PLA                       ; get args_pointer from stack
  STA .args_pointer         ; store args_pointer in .args_pointer
  PLA                       ; get pointer to input string from stack
  STA .string_pointer       ; store input string pointer in .string_pointer

  MOVBA                     ; move return address back to A
  PHA                       ; push it back to stack

  LDI 0
  STA .chars_printed

lp:
  ; load *string_pointer into A
  LPA .string_pointer                 ; load mem[mem[.string_pointer]] into A
  CPI 0
  JPZ end                             ; if we reach null, return
  CPI 37
  JNZ print_char                      ; if not '%', print character
  ; -- handle format specifier --
  JSR increment_string_pointer
  LPA .string_pointer                 ; load next character (format specifier)
  CPI 0
  JPZ end                             ; if we reach null, return
  CPI 100                             ; 'd'
  JPZ print_signed_decimal
  CPI 117                             ; 'u'
  JPZ print_unsigned_decimal
  CPI 120                             ; 'x'
  JPZ print_hexadecimal
  CPI 115                             ; 's'
  JPZ print_string
  CPI 37                              ; '%'
  JPZ print_percent
  ; -- unknown format specifier, just print it as-is, but first print the initial '%' --
  LDI 37                              ; '%'
  JSR @write_char
  JSR increment_counter
  ; fallthrough to print the unknown specifier character itself
print_char:                           ; print next character, whether it is the unknown specifier or a normal character
  JSR @write_char
  JSR increment_string_pointer
  JSR increment_counter
  JMP lp

print_percent:
  LDI 37                              ; '%'
  JSR @write_char
  JSR increment_counter
  JSR increment_string_pointer
  JMP lp

print_string:
  ; get argument (pointer to string)
  LDA .args_pointer
  LPA .arg1
  JSR @printez
  ADD .chars_printed
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_signed_decimal:
  ; get argument (signed integer)
  LDA .args_pointer
  PHA
  JSR @display_int
  JSR increment_counter            ; does not return number of chars printed, TODO: fix or workaround
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_unsigned_decimal:
  ; get argument (unsigned integer)
  LDA .args_pointer
  PHA
  JSR @display_number
  JSR increment_counter            ; does not return number of chars printed, TODO: fix or workaround
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_hexadecimal:
  ; get argument (unsigned integer)
  LDA .args_pointer
  PHA
  JSR @display_hex
  JSR increment_counter            ; does not return number of chars printed, TODO: fix or workaround
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

increment_counter:
  LDA .chars_printed
  ADI 1
  STA .chars_printed
  RET

increment_args_pointer:
  LDA .args_pointer
  ADI 1
  STA .args_pointer
  RET

increment_string_pointer:
  LDA .string_pointer
  ADI 1
  STA .string_pointer
  RET

end:
  RET