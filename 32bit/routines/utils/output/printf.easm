;! name: PRINTF
;! entry: printf
;! deps: print, display_int, display_hex, display_number, display_word, display_q7_8, write_char, newline
;! abi: args
;! bss: auto
;! align: 1

; --- Print a formatted null-terminated string to standard output, followed by a newline ---

; Call signature: printf(SP - 3, SP - 2) = printf(string_pointer, args_pointer)
; Inputs:
;   Stack Pointer - 3 = pointer to string to be formatted
;   Stack Pointer - 2 = pointer to arguments
; Returns: A = number of characters printed (including final newline)

; example args pointer = some_mem_location
; mem[some_mem_location + 0] = first argument
; mem[some_mem_location + 1] = second argument
; mem[some_mem_location + 2] = third argument
; ...
; e.g. a string and an integer:
; mem[some_mem_location + 0] = pointer to string -> for %s, we pass this to print() with skip_newline=1
; mem[some_mem_location + 1] = integer value
; ...

; -- format specifiers supported:
; %d - signed decimal integer
; %u - unsigned decimal integer
; %x - hexadecimal integer (uppercase)
; %s - string (no newline)
; %% - literal percent sign
; %b - binary word (full width with leading zeros)
; %f - Q7.8 fixed-point decimal "[-]I.FFF"

string_pointer  = .bss + 0
args_pointer    = .bss + 1
chars_printed   = .bss + 2
_tmp            = .bss + 3
_saved_arg      = .bss + 4
; no extra locals needed for digit counting; display_* will set .__res3

printf:
  PLA                       ; get return address from stack
  MOVAB                     ; move return address to B for now

  PLA                       ; get args_pointer from stack
  STA .args_pointer         ; store args_pointer in .args_pointer
  PLA                       ; get pointer to input string from stack
  STA .string_pointer       ; store input string pointer in .string_pointer

  MOVBA                     ; move return address back to A
  PHA                       ; push it back to stack

  LDI 0
  STA .chars_printed

lp:
  ; load *string_pointer into A
  LPA .string_pointer                 ; A = mem[mem[.string_pointer]]
  CPI 0
  JPZ end                             ; stop at null terminator
  CPI 37                              ; '%'
  JNZ print_char                      ; normal character
  ; -- handle format specifier --
  JSR increment_string_pointer
  LPA .string_pointer                 ; load next character (format specifier)
  CPI 0
  JPZ end                             ; premature end
  CPI 100                             ; 'd'
  JPZ print_signed_decimal
  CPI 117                             ; 'u'
  JPZ print_unsigned_decimal
  CPI 120                             ; 'x'
  JPZ print_hexadecimal
  CPI 115                             ; 's'
  JPZ print_string
  CPI 98                              ; 'b'
  JPZ print_binary
  CPI 102                             ; 'f'
  JPZ print_q78
  CPI 37                              ; '%'
  JPZ print_percent
  ; -- unknown specifier: print '%' then the char itself --
  STA ._tmp                           ; save unknown specifier
  LDI 37                              ; '%'
  JSR @write_char
  JSR increment_counter
  LDA ._tmp
  JSR @write_char
  JSR increment_counter
  JSR increment_string_pointer
  JMP lp

print_char:                           ; print next character (already in A)
  JSR @write_char
  JSR increment_string_pointer
  JSR increment_counter
  JMP lp

print_percent:
  LDI 37                              ; '%'
  JSR @write_char
  JSR increment_counter
  JSR increment_string_pointer
  JMP lp

print_string:
  ; Argument: pointer to string in mem[mem[args_pointer]]
  LPA .args_pointer                   ; A = string pointer
  ; call print(input_string_pointer, skip_newline=1, max_length=0)
  PHA                                 ; push input string pointer
  LDI 1                               ; skip_newline = 1 (don't add newline here)
  PHA
  LDI 0                               ; max_length = 0 (until null)
  PHA
  JSR @print
  ; returns A = chars printed
  ADD .chars_printed
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_unsigned_decimal:
  ; Argument value
  LPA .args_pointer                   ; A = value
  STA ._saved_arg
  LDA ._saved_arg
  JSR @display_number
  ; .__res3 = digits printed
  LDA .chars_printed
  ADD .__res3
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_hexadecimal:
  ; Argument value
  LPA .args_pointer                   ; A = value
  STA ._saved_arg
  JSR @display_hex
  ; .__res3 = digits printed
  LDA .chars_printed
  ADD .__res3
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_signed_decimal:
  ; Argument value
  LPA .args_pointer                   ; A = value
  STA ._saved_arg
  JSR @display_int
  ; .__res3 = digits + optional '-'
  LDA .chars_printed
  ADD .__res3
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_binary:
  ; Argument value
  LPA .args_pointer                   ; A = value
  STA ._saved_arg
  JSR @display_word
  ; .__res3 = bits printed
  LDA .chars_printed
  ADD .__res3
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

print_q78:
  ; Argument value (Q7.8 fixed-point)
  LPA .args_pointer                   ; A = value
  STA ._saved_arg
  JSR @display_q7_8
  ; .__res3 = chars printed
  LDA .chars_printed
  ADD .__res3
  STA .chars_printed
  JSR increment_args_pointer
  JSR increment_string_pointer
  JMP lp

increment_counter:
  LDA .chars_printed
  ADI 1
  STA .chars_printed
  RET

increment_args_pointer:
  LDA .args_pointer
  ADI 1
  STA .args_pointer
  RET

increment_string_pointer:
  LDA .string_pointer
  ADI 1
  STA .string_pointer
  RET

end:
  ; append a final newline and count it
  JSR @newline
  LDA .chars_printed
  ADI 1
  STA .chars_printed
  LDA .chars_printed
  RET