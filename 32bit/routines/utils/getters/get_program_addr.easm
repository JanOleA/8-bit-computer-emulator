;! name: GETPROGADDR
;! entry: get_program_address
;! deps: string_compare
;! abi: all
;! bss: auto
;! align: 1

; Program table row layout (32 words stride): base still at +16.
; Flags present at +22..+31 (flag0 = callable) but not used here.


; --- Get the address of a program from the program table, based on its name ---
; --- Pointer to name as input in .__arg1, result is a number in .__res1, null if not found ---


get_program_address:
  LDA .__arg1
  STA .bss
  LDI 0
  STA .bss + 1          ; current location in __sys_prog_table
compare_loop:
  LDI .__sys_prog_table
  ADD .bss + 1
  STA .bss + 2          ; store in bss + 2 to use in string_compare later
  LAP                   ; push memory address to stack, load value at memory address
  CPI 0                 ; if the name starts with null, we reached the end of the program table
  JPZ no_match
  LDA .bss + 2
  PHA
  LDA .bss
  PHA
  JSR @string_compare
                        ; result is in __res1 and in A register
  CPI 1
  JPZ match
  ; -- no match --
  LDA .bss + 1
  ADI 32                ; forward by 32 (new program table row stride)
  STA .bss + 1
  JMP compare_loop
match:
  LDI .__sys_prog_table
  ADD .bss + 1          ; location of string in program table
  ADI 22                ; location of flags 
  LAP                   ; get stored "callable" flag from the pointer
  STA .__res2
  LDI .__sys_prog_table
  ADD .bss + 1          ; location of string in program table
  ADI 16                ; location of base (unchanged: base field still at index 16 within 32-word row)
  LAP                   ; get stored base from the pointer
  STA .__res1
  RET
no_match:
  LDI 0
  STA .__res1
  STA .__res2
  RET