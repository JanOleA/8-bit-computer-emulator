;! name: GETMNEMONICN
;! entry: get_mnemonic
;! deps: string_compare, parse_number, buffer_to_separator, echon
;! abi: os
;! bss: auto
;! align: 4

.separator = ","
.mnemonics = "LDA,1,ADD,2,SUB,3,STA,4,LDI,5,JMP,6,JPC,7,JPZ,8,KEI,9,ADI,10,SUI,11,CMP,12,PHA,13,PLA,14,LDS,15,JSR,16,RET,17,SAS,18,LAS,19,LDB,20,CPI,21,RSA,22,LSA,23,DIS,24,DIC,25,LDD,26,JNZ,27,STB,28,MOVBA,29,MOVAB,30,LSP,31,MVASP,32,MVBSP,33,SUM,34,LAP,35,LPA,36,DIA,37,OUT,254,HLT,255"
; -- keep mnemonics in sync with cpu_sim.py and assembler_core.py --

; bss       : pointer to input string
; bss + 1   : current position in mnemonics string

; --- Compare the string pointed to by .arg1 to assembly mnemonics and return (in res1) the corresponding instruction value, if it exists (otherwise null) ---

get_mnemonic:
  LDA .arg1           ; .arg1 holds the pointer to the input string
  STA .bss
  LDI .mnemonics      ; store current position of mnemonics string in bss + 1
  STA .bss + 1
compare:
  JSR buf_to_sep
  LDA .res1
  PHA                 ; store pointer to buffered string as first argument
  LDA .bss
  PHA                 ; push pointer to input string from .bss as second argument
  JSR @string_compare
  CPI 1
  JPZ match
  ; get character at read_pointer
  LPA .bss + 1                ; load mem[mem[.bss + 1]] into A
  CPI 0                   ; if we reach null, end
  JPZ end_no_match
  JMP compare
match:
  JSR buf_to_sep          ; parse numeric token buffered by buffer_to_separator (pointer returned in .res1)
  LDA .res1
  PHA
  JSR @parse_number
  STA .res1               ; return memory location in .res1
  RET
end_no_match:
  LDI 0
  STA .res1
  RET

; --- helper to buffer the next string to compare ---
buf_to_sep:          
  LDA .separator                ; Set separator byte (dereference first char of .separator)
  STA .arg2
  LDA .bss + 1                  ; Start from current pointer into mnemonics string
  STA .arg1                     ; Buffer token up to separator. Pointer to buffered string in res1; length -> .res2
  JSR @buffer_to_separator
  LDA .res2
  CPI 0                         ; compare with 0
  JPZ bts_done                  ; jump to end if so
  LDA .bss + 1
  ADD .res2                     ; Advance current pointer by token length
  STA .bss + 1
  LPA .bss + 1                  ; If current char is the separator, skip it as well; if null, do not                ; load mem[mem[.bss + 1                  ; If current char is the separator, skip it as well; if null, do not]] into A
  CMP .arg2
  JPZ bts_skip_sep
  JMP bts_done
bts_skip_sep:
  LDA .bss + 1
  ADI 1
  STA .bss + 1
bts_done:
  RET
