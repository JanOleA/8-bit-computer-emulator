;! name: PARSENUM
;! entry: parse_number
;! deps: 
;! abi: os
;! bss: auto
;! align: 4

; Parse a text decimal number from pointer (first argument) into integer in .bss (stops at first non-digit)
; returns the number in A and the updated pointer in .arg1 (backwards compat)
parse_number:
  PLA                 ; pull return address into A
  MOVAB               ; move it to B temporarily

  PLA
  STA .bss + 3        ; argument pointer in .bss + 3

  MOVBA               ; move return address back to A
  PHA                 ; push return address back to stack

  LDI 0
  STA .bss
pn_loop:
  LPA .bss + 3        ; A = current char                ; load mem[mem[.bss + 3]] into A
  CPI 48              ; if A < '0' -> done
  JPC pn_ge_48
  JMP pn_done
pn_ge_48:
  CPI 58              ; if A >= ':' -> done
  JPC pn_done
  ; convert to digit and accumulate: res1 = res1*10 + digit
  SUI 48
  STA .bss + 2        ; temp digit
  LDA .bss
  LSA
  STA .bss + 1        ; tmp = res*2
  LSA
  LSA                 ; A = res*8
  ADD .bss + 1        ; A = res*10
  ADD .bss + 2
  STA .bss
  ; advance pointer
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  JMP pn_loop
pn_done:
  ; return pointer to the first non-digit character in .arg1 so callers
  ; can verify token boundaries (maintains old behaviour expected by callers)
  LDA .bss + 3
  STA .arg1
  LDA .bss
  STA .res1
  RET