;! name: TESTMEM
;! entry: testmem
;! deps: display_number, print, printez, newline, write_char
;! abi: all argv
;! bss: auto
;! align: 1
;! callable: yes

; --- Print a list of memory regions with 100 or more contiguous nulls, as well as the memory region with the largest contiguous block of nulls --

; bss + 0 : current address
; bss + 1 : current test site start
; bss + 2 : current test site size
; bss + 3 : largest test site start
; bss + 4 : largest test site stop
; bss + 5 : largest test site size
; bss + 6 : in zero region

.largest_text = "Largest memory region with nulls:"
.largest_text_2 = "[%u, %u) Size: %u"

testmem:
  LDI 0
  STA .bss
  STA .bss + 1
  STA .bss + 2
  STA .bss + 3
  STA .bss + 4
  STA .bss + 5
  STA .bss + 6
  JMP check_zero

is_zero:
  LDA .bss + 6          ; if in_zero_region is 1, skip setting start of site
  CPI 1
  JPZ skip_startsite
  LDA .bss
  STA .bss + 1          ; set the start of current site to memory address
  LDI 1
  STA .bss + 6          ; set flag for being in zero region
skip_startsite:
  LDA .bss
  ADI 1
  JPC end               ; increment memory address, if carry, end
  STA .bss
  LDA .bss + 2
  ADI 1
  STA .bss + 2
check_zero:
  LPA .bss                ; load mem[mem[.bss]] into A
  CPI 0
  JPZ is_zero
not_zero:               ; if it's not zero
  LDA .bss              ; first increment memory address
  ADI 1
  JPC end               ; increment memory address, if carry, end
  STA .bss
  LDA .bss + 6          ; see if we previously were in a zero region
  CPI 1
  JPZ end_zero_region
  JMP check_zero        ; we were not, so go back to check_zero
end_zero_region:
  LDI 0
  STA .bss + 6
  LDI 100
  CMP .bss + 2          ; compare size of this region with 100, if 100 is GEQ A, skip printing
  JPC skip_print
print_current:          ; print the start and size of the current region
  JSR display_current
skip_print:
  LDA .bss + 2
  CMP .bss + 5
  JPC update_largest    ; if the current region is GEQ than the previous largest
  LDI 0
  STA .bss + 2
  JMP check_zero
update_largest:
  LDA .bss + 1
  STA .bss + 3
  LDA .bss + 2
  STA .bss + 5
  LDI 0
  STA .bss + 2
  JMP check_zero
end:
  LDA .bss + 6
  CPI 1
  JPZ end_on_zero_region
  JMP print_largest

end_on_zero_region:
  JSR display_current
  LDA .bss + 5
  CMP .bss + 2
  JPC print_largest    ; if the largest region is GEQ than the current, skip to end
  LDA .bss + 1
  STA .bss + 3
  LDA .bss + 2
  STA .bss + 5
print_largest:
  LDI .largest_text
  JSR print_newline

  LDI .largest_text_2
  PHA
  LDI .bss + 3          ; args are bss + 3, + 4 and + 5, so pass the start as a pointer for all three
  PHA

  LDA .bss + 3
  ADD .bss + 5
  STA .bss + 4

  JSR @printf
  RET


; -- print helpers, null terminated. Pointer to text must be in A register --
print_newline:
  PHA
  JSR @printez
  RET

print_no_newline:
  PHA
  LDI 1
  PHA
  LDI 0
  PHA
  JSR @print
  RET

display_current:
  LDA .bss + 1
  JSR @display_number
  LDI 32
  JSR @write_char
  JSR @write_char
  JSR @write_char
  LDA .bss + 1
  ADD .bss + 2
  JSR @display_number
  LDI 32
  JSR @write_char
  JSR @write_char
  JSR @write_char
  LDA .bss + 2
  JSR @display_number
  JSR @newline
  RET