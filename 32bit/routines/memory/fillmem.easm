;! name: FILLMEM
;! entry: start
;! deps: printf
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes

.invalid_address = "Invalid mem.addr. in fillmem: %u"
.usage = "Usage: FILLMEM <addr> <len> <value>"

; Fill memory range with a value.
; Inputs (OS ABI):
;   .bss + 0 = dst
;   .bss + 1 = len
;   .bss + 2 = value

start:
  ; require at least 3 args
  LDA .__argv_base
  CPI 3
  JPC cl_go
  LDI .usage
  PHA
  PHA             ; no replacement in the string, but printf pulls two arguments from stack, so give it an extra
  JSR @printf
  RET

cl_go:
  LDA .__argv_base + 1
  PHA
  JSR @parse_number
  STA .bss

  LDA .__argv_base + 2
  PHA
  JSR @parse_number
  STA .bss + 1

  LDA .__argv_base + 3
  PHA
  JSR @parse_number
  STA .bss + 2

fill:
  ; if len == 0: return
  LDA .bss + 1
  CPI 0
  JPZ fl_ret
  ; ptr = dst
  LDA .bss
  STA .__work2
  ; cnt = len
  LDA .bss + 1
  STA .__work4
fl_loop:
  LDA .__work4
  CPI 0
  JPZ fl_ret
  ; *ptr = value
  LDA .__work2
  CMP .__sys_reserved_region_end         ; if address >= reserved region end, OK
  JPC fill_forward_address_ok
  JMP fill_invalid_address
fill_forward_address_ok:
  PHA
  LDA .bss + 2
  SAS
  ; advance
  LDA .__work2
  ADI 1
  STA .__work2
  LDA .__work4
  SUI 1
  STA .__work4
  JMP fl_loop

fill_invalid_address:
  LDI .invalid_address
  PHA
  LDI .__work2
  PHA
  JSR @printf
fl_ret:
  RET

