;! name: DUMP
;! entry: main
;! deps: display_number, newline, write_char
;! abi: os
;! bss: auto
;! align: 4

; DUMP <addr> <nwords>
; Prints decimal words from memory starting at <addr>,
; in fixed-width, space-padded columns (width = 9 chars).

; BSS locals
addr  = .bss          ; current address pointer
; .bss + 1  = remaining count
; .bss + 2  = column counter (fields per row)
; .bss + 3  = work value for digit count (mutable)
; .bss + 4  = digit count
; .bss + 5  = padding spaces to print
; .bss + 6  = original value (preserved)

main:
  ; argc at [argv_base]
  LDA .argv_base
  CPI 2               ; need at least 2 args
  JPZ dmp_go
  RET

dmp_go:
  ; parse first arg -> addr
  LDA .argv_base + 1
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
dmp_pn1:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ dmp_pn1_done
  CPI 32
  JPZ dmp_pn1_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP dmp_pn1
dmp_pn1_done:
  LDA .res1
  STA .addr

  ; parse second arg -> lenv
  LDA .argv_base + 2
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
dmp_pn2:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ dmp_pn2_done
  CPI 32
  JPZ dmp_pn2_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP dmp_pn2
dmp_pn2_done:
  LDA .res1
  STA .bss + 1

  ; init column counter
  LDI 0
  STA .bss + 2

dmp_loop:
  LDA .bss + 1
  CPI 0
  JPZ dmp_end

  ; read word at [addr] into .arg1 safely
  LPA .addr                ; load mem[mem[.addr]] into A
  STA .arg1
  STA .bss + 6        ; save original value
  STA .bss + 3        ; working copy for digit count

  ; compute decimal digit count into .bss + 4
  JSR dmp_digit_count
  ; compute left padding = 9 - digits
  LDI 9
  SUB .bss + 4
  STA .bss + 5
  ; emit left padding spaces
  JSR dmp_emit_padding
  ; print the number right-aligned in 9-char field
  LDA .bss + 6
  STA .arg1
  JSR @display_number

  ; advance
  LDA .addr
  ADI 1
  STA .addr
  LDA .bss + 1
  SUI 1
  STA .bss + 1

  ; column handling: 4 per row
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  CPI 4
  JPZ dmp_newline
  JMP dmp_loop

dmp_newline:
  JSR @newline
  LDI 0
  STA .bss + 2
  JMP dmp_loop

dmp_end:
  JSR @newline
  RET

; Count decimal digits of value in .bss + 3
dmp_digit_count:
  ; if value == 0 -> digits = 1
  LDA .bss + 3
  CPI 0
  JPZ ddc_zero
  LDI 0
  STA .bss + 4
ddc_loop:
  LDA .bss + 3
  CPI 0
  JPZ ddc_done
  ; divide by 10 (A=quotient, .res2=remainder)
  LDA .bss + 3
  STA .arg1
  LDI 10
  STA .arg2
  JSR @divide
  STA .bss + 3       ; carry quotient forward
  LDA .bss + 4
  ADI 1
  STA .bss + 4
  JMP ddc_loop
ddc_zero:
  LDI 1
  STA .bss + 4
ddc_done:
  RET

; Emit .bss + 5 spaces (left padding)
dmp_emit_padding:
  LDA .bss + 5
  CPI 0
  JPZ dep_done
dep_loop:
  LDI 32
  STA .char
  JSR @write_char
  LDA .bss + 5
  SUI 1
  STA .bss + 5
  JPZ dep_done
  JMP dep_loop
dep_done:
  RET
