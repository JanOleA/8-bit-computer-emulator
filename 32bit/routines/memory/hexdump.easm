;! name: HEXDUMP
;! entry: main
;! deps: divide, newline, write_char
;! abi: os
;! bss: auto
;! align: 4

; HEXDUMP <addr> <nwords>
; Prints 32-bit words in hexadecimal, four columns per row,
; each value right-aligned in 8 characters (space-padded).

; Data (module-local)
.hex_map = "0123456789ABCDEF"

; BSS locals
addr       = .bss          ; current address pointer (others via .bss + N)

main:
  ; argc at [argv_base]
  LDA .argv_base
  CPI 2               ; need at least 2 args
  JPZ hx_go
  RET

hx_go:
  ; parse first arg -> addr
  LDA .argv_base + 1
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
hx_pn1:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ hx_pn1_done
  CPI 32
  JPZ hx_pn1_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP hx_pn1
hx_pn1_done:
  LDA .res1
  STA .addr

  ; parse second arg -> lenv
  LDA .argv_base + 2
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
hx_pn2:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ hx_pn2_done
  CPI 32
  JPZ hx_pn2_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP hx_pn2
hx_pn2_done:
  LDA .res1
  STA .bss + 1

  ; init column counter
  LDI 0
  STA .bss + 2

hx_loop:
  LDA .bss + 1
  CPI 0
  JPZ hx_end

  ; read word at [addr] into A
  LPA .addr                ; load mem[mem[.addr]] into A
  STA .arg1           ; keep a copy if needed
  ; print 8 hex digits from A
  JSR print_hex8

  ; advance
  LDA .addr
  ADI 1
  STA .addr
  LDA .bss + 1
  SUI 1
  STA .bss + 1

  ; column handling: 4 per row
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  CPI 4
  JPZ hx_newline
  ; else space and continue
  LDI 32
  JSR @write_char
  JMP hx_loop

hx_newline:
  JSR @newline
  LDI 0
  STA .bss + 2
  JMP hx_loop

hx_end:
  JSR @newline
  RET

; Prints .arg1 as up to 8 hex digits (most significant first),
; space-padded on the left to width 8
print_hex8:
  ; Capture the input word from .arg1 into a local temp (.bss + 4)
  ; Caller stored the memory word into .arg1 before calling us.
  LDA .arg1
  STA .bss + 4       ; local working value
  LDI 0
  STA .bss + 3       ; digit counter
  ; Special case: if value==0, push single '0' and set digits=1
  LDA .bss + 4
  CPI 0
  JPZ ph_zero
ph_loop:
  ; Divide current value by 16, push remainder as hex digit
  LDA .bss + 4
  STA .arg1           ; dividend for divide
  LDI 16
  STA .arg2
  ; A = quotient, .res2 = remainder (0..15)
  JSR @divide
  ; carry quotient forward locally (A holds quotient)
  STA .bss + 4
  ; map remainder (0..15) to ASCII and push to stack
  LDA .res2
  CPI 10
  JPC ph_hex_ge10
  ADI 48              ; '0'..'9'
  JMP ph_hex_push
ph_hex_ge10:
  SUI 10
  ADI 65              ; 'A'..'F'
ph_hex_push:
  PHA                 ; push ASCII char
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  ; continue until working value becomes 0
  LDA .bss + 4
  CPI 0
  JPZ ph_pad
  JMP ph_loop
ph_zero:
  LDI 48              ; '0'
  PHA
  LDI 1
  STA .bss + 3
  JMP ph_pad
ph_pad:
  ; Emit spaces to left-pad to width 8: pad = 8 - digits
  LDI 8
  SUB .bss + 3
  STA .bss + 5        ; pad count
ph_pad_loop:
  LDA .bss + 5
  CPI 0
  JPZ ph_print
  LDI 32
  JSR @write_char
  LDA .bss + 5
  SUI 1
  STA .bss + 5
  JMP ph_pad_loop
ph_print:
  ; pop and print 'digits' ASCII hex digits
  PLA
  JSR @write_char
  LDA .bss + 3
  SUI 1
  STA .bss + 3
  JPZ ph_done
  JMP ph_print
ph_done:
  RET
