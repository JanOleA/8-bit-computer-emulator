;! name: HEXDUMP
;! entry: main
;! deps: divide, newline, write_char
;! abi: all
;! bss: auto
;! align: 4

; HEXDUMP <addr> <nwords>
; Dynamic formatting based on OS ABI symbol .bits_avail:
;   if .bits_avail <= 16  => 16-bit mode: 8 columns, width 4 (space padded)
;   else                  => 32-bit mode: 4 columns, width 8 (space padded)
; This lets the same routine adapt to different machine configurations.

; Data (module-local)
.hex_map = "0123456789ABCDEF"

; BSS locals
addr       = .bss          ; current address pointer (others via .bss + N)

main:
  ; argc at [argv_base]
  LDA .argv_base
  CPI 2               ; need at least 2 args
  JPZ hx_go
  RET

hx_go:
  ; parse first arg -> addr
  LDA .argv_base + 1
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
hx_pn1:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ hx_pn1_done
  CPI 32
  JPZ hx_pn1_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP hx_pn1
hx_pn1_done:
  LDA .res1
  STA .addr

  ; parse second arg -> lenv
  LDA .argv_base + 2
  STA .res2           ; res2 = pointer to string
  LDI 0
  STA .res1
hx_pn2:
  LPA .res2                ; load mem[mem[.res2]] into A
  CPI 0
  JPZ hx_pn2_done
  CPI 32
  JPZ hx_pn2_done
  SUI 48
  STA .char
  LDA .res1
  LSA
  STA .pow2
  LSA
  LSA
  ADD .pow2
  STA .res1
  LDA .res1
  ADD .char
  STA .res1
  LDA .res2
  ADI 1
  STA .res2
  JMP hx_pn2
hx_pn2_done:
  LDA .res1
  STA .bss + 1

  ; Determine formatting mode from .bits_avail
  LDA .bits_avail
  CPI 17
  JPC hx_set_32          ; if A >= 17 (carry clear until A < 17?) we branch (Using CPI semantics: carry set if A >= immediate; we want >16 so >=17) -> if A >= 17 jump to 32-bit
  ; 16-bit mode
  LDI 0
  STA .bss + 6           ; mode = 0 (16-bit)
  JMP hx_mode_done
hx_set_32:
  LDI 1
  STA .bss + 6           ; mode = 1 (32-bit)
hx_mode_done:

  ; init column counter
  LDI 0
  STA .bss + 2

hx_loop:
  LDA .bss + 1
  CPI 0
  JPZ hx_end

  ; read word at [addr] into A (cell interpreted per mode)
  LPA .addr                ; load mem[mem[.addr]] into A
  STA .arg1           ; keep a copy if needed
  ; conditional print based on mode
  LDA .bss + 6
  CPI 0
  JPZ hx_do16
  JSR print_hex8
  JMP hx_after_print
hx_do16:
  JSR print_hex4
hx_after_print:

  ; advance
  LDA .addr
  ADI 1
  STA .addr
  LDA .bss + 1
  SUI 1
  STA .bss + 1

  ; column handling depends on mode
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  LDA .bss + 6
  CPI 0
  JPZ hx_chk16cols
  ; 32-bit mode: 4 columns
  LDA .bss + 2
  CPI 4
  JPZ hx_newline
  JMP hx_space
hx_chk16cols:
  ; 16-bit mode: 8 columns
  LDA .bss + 2
  CPI 8
  JPZ hx_newline
hx_space:
  ; else space and continue
  LDI 32
  JSR @write_char
  JMP hx_loop

hx_newline:
  JSR @newline
  LDI 0
  STA .bss + 2
  JMP hx_loop

hx_end:
  JSR @newline
  RET

; Prints .arg1 as up to 4 hex digits (most significant first),
; space-padded on the left to width 4
print_hex4:
  ; Capture the input word from .arg1 into a local temp (.bss + 4)
  ; Caller stored the memory word into .arg1 before calling us.
  LDA .arg1
  STA .bss + 4       ; local working value
  LDI 0
  STA .bss + 3       ; digit counter
  ; Special case: if value==0, push single '0' and set digits=1
  LDA .bss + 4
  CPI 0
  JPZ ph_zero
ph_loop:
  ; Divide current value by 16, push remainder as hex digit
  LDA .bss + 4
  STA .arg1           ; dividend for divide
  LDI 16
  STA .arg2
  ; A = quotient, .res2 = remainder (0..15)
  JSR @divide
  ; carry quotient forward locally (A holds quotient)
  STA .bss + 4
  ; map remainder (0..15) to ASCII and push to stack
  LDA .res2
  CPI 10
  JPC ph_hex_ge10
  ADI 48              ; '0'..'9'
  JMP ph_hex_push
ph_hex_ge10:
  SUI 10
  ADI 65              ; 'A'..'F'
ph_hex_push:
  PHA                 ; push ASCII char
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  ; continue until working value becomes 0
  LDA .bss + 4
  CPI 0
  JPZ ph_pad
  JMP ph_loop
ph_zero:
  LDI 48              ; '0'
  PHA
  LDI 1
  STA .bss + 3
  JMP ph_pad
ph_pad:
  ; Emit spaces to left-pad to width 4: pad = 4 - digits
  LDI 4
  SUB .bss + 3
  STA .bss + 5        ; pad count
ph_pad_loop:
  LDA .bss + 5
  CPI 0
  JPZ ph_print
  LDI 32
  JSR @write_char
  LDA .bss + 5
  SUI 1
  STA .bss + 5
  JMP ph_pad_loop
ph_print:
  ; pop and print 'digits' ASCII hex digits
  PLA
  JSR @write_char
  LDA .bss + 3
  SUI 1
  STA .bss + 3
  JPZ ph_done
  JMP ph_print
ph_done:
  RET

; Prints .arg1 as up to 8 hex digits (most significant first),
; space-padded on the left to width 8 (legacy 32-bit mode)
print_hex8:
  LDA .arg1
  STA .bss + 4
  LDI 0
  STA .bss + 3
  LDA .bss + 4
  CPI 0
  JPZ ph8_zero
ph8_loop:
  LDA .bss + 4
  STA .arg1
  LDI 16
  STA .arg2
  JSR @divide
  STA .bss + 4
  LDA .res2
  CPI 10
  JPC ph8_ge10
  ADI 48
  JMP ph8_push
ph8_ge10:
  SUI 10
  ADI 65
ph8_push:
  PHA
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  LDA .bss + 4
  CPI 0
  JPZ ph8_pad
  JMP ph8_loop
ph8_zero:
  LDI 48
  PHA
  LDI 1
  STA .bss + 3
  JMP ph8_pad
ph8_pad:
  LDI 8
  SUB .bss + 3
  STA .bss + 5
ph8_pad_loop:
  LDA .bss + 5
  CPI 0
  JPZ ph8_print
  LDI 32
  JSR @write_char
  LDA .bss + 5
  SUI 1
  STA .bss + 5
  JMP ph8_pad_loop
ph8_print:
  PLA
  JSR @write_char
  LDA .bss + 3
  SUI 1
  STA .bss + 3
  JPZ ph8_done
  JMP ph8_print
ph8_done:
  RET
