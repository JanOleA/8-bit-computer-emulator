;! name: DISPNUM
;! entry: display_number
;! deps: divide, write_char
;! abi: os
;! bss: auto
;! align: 20

; BSS locals
; .bss      = working value (dividend)
; .bss + 1  = digit count
; .bss + 2  = input value, to return it to the A register at the end

display_number:
  ; Copy input value into local working storage
  LDA .arg1
  STA .bss
  STA .bss + 2
  ; Handle zero specially -> print '0'
  LDA .bss
  CPI 0
  JPZ dn_zero
  ; Reset digit count
  LDI 0
  STA .bss + 1
dn_loop:
  ; Divide working value by 10, push remainder as ASCII
  LDA .bss
  CPI 0
  JPZ dn_print
  ; prepare args for divide
  LDA .bss
  STA .arg1
  LDI 10
  STA .arg2
  ; divide by 10: returns A=quotient, .res2=remainder
  JSR @divide
  STA .bss            ; carry quotient forward
  LDA .res2
  ADI 48
  PHA                 ; push ASCII digit
  ; increment digit count
  LDA .bss + 1
  ADI 1
  STA .bss + 1
  JMP dn_loop

dn_print:
  ; Pop and print digits
  LDA .bss + 1
  CPI 0
  JPZ dn_done
dn_pop:
  PLA
  STA .char
  JSR @write_char
  LDA .bss + 1
  SUI 1
  STA .bss + 1
  JPZ dn_done
  JMP dn_pop

dn_zero:
  LDI 48
  STA .char
  JSR @write_char
  LDA .bss + 2
  RET

dn_done:
  LDA .bss + 2
  RET
