;! name: CPYMEM
;! entry: copy_mem
;! deps: display_number, parse_number
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes

; Copy memory safely handling overlap.
; Inputs (OS ABI):
;   bss + 0 = src
;   bss + 1 = dst
;   bss + 2 = len

copy_mem:
  ; take three arguments. If less are given, use numbers in __arg1, __arg2 and __num_digits (src, dst, len)
  LDA .__argv_base
  CPI 3
  JPZ cl_go
  LDA .__arg1
  STA .bss
  LDA .__arg2
  STA .bss + 1
  LDA .__num_digits
  STA .bss + 2
  JMP cpy

cl_go:
  LDA .__argv_base + 1
  PHA
  JSR @parse_number
  STA .bss

  LDA .__argv_base + 2
  PHA
  JSR @parse_number
  STA .bss + 1

  LDA .__argv_base + 3
  PHA
  JSR @parse_number
  STA .bss + 2

cpy:
  ; if len == 0: return
  LDA .bss + 2
  CPI 0
  JPZ cpy_ret

  ; __work1 = src_end = src + len
  LDA .bss
  ADD .bss + 2
  STA .__work1

  ; if dst >= src and dst < src_end then backward else forward
  LDA .bss + 1
  CMP .bss
  JPC cpy_ge_src
  JMP cpy_forward

cpy_ge_src:
  LDA .bss + 1
  CMP .__work1
  JPC cpy_forward     ; dst >= src_end -> forward
  JMP cpy_backward    ; overlap -> backward

; forward copy
cpy_forward:
  LDA .bss
  STA .__work2          ; src_ptr
  LDA .bss + 1
  STA .__work3          ; dst_ptr
  LDA .bss + 2
  STA .__work4          ; count
cf_loop:
  LDA .__work4          ; load count
  CPI 0               ; compare count to 0
  JPZ cpy_ret         ; if count is 0, return
  ; A = *dst_ptr
  LDA .__work3
  PHA ; push dst_prt to stack
  ; A = *src_ptr
  LDA .__work2
  PHA ; push src_ptr to stack
  LAS ; pop pointer from stack, get source mem content to A
  SAS ; pop dst_ptr from stack, store A
  ; advance ptrs and dec count
  LDA .__work2
  ADI 1
  STA .__work2
  LDA .__work3
  ADI 1
  STA .__work3
  LDA .__work4
  SUI 1
  STA .__work4
  JMP cf_loop

; backward copy
cpy_backward:
  ; src_ptr = src + len - 1
  LDA .bss
  ADD .bss + 2
  SUI 1
  STA .__work2
  ; dst_ptr = dst + len - 1
  LDA .bss + 1
  ADD .bss + 2
  SUI 1
  STA .__work3
  LDA .bss + 2
  STA .__work4
cb_loop:
  LDA .__work4
  CPI 0
  JPZ cpy_ret
  ; A = *dst_ptr
  LDA .__work3
  PHA ; push dst_prt to stack
  ; A = *src_ptr
  LDA .__work2
  PHA ; push src_ptr to stack
  LAS ; pop pointer from stack, get source mem content to A
  SAS ; pop dst_ptr from stack, store A
  ; decrement ptrs and count
  LDA .__work2
  SUI 1
  STA .__work2
  LDA .__work3
  SUI 1
  STA .__work3
  LDA .__work4
  SUI 1
  STA .__work4
  JMP cb_loop

cpy_ret:
  RET

