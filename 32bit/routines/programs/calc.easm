;! name: CALC
;! entry: calc
;! deps: display_int, display_number, divide, mult, parse_number, newline, write_char, pow, sqrt, print, printez
;! abi: all
;! bss: none
;! align: 1
;! callable: yes

; CALC <num1> <op> <num2>
; Computes num1 <op> num2 where op is one of + - * /
; Prints the result in decimal using display_int or display_number as appropriate.

.residual_text = "Residual="
.distance_text = "Distance to next square="

calc:
  ; require at least 2 args
  LDA .__argv_base
  CPI 2
  JPC cl_go
  RET

cl_go:
  ; parse first number -> __work1
  LDA .__argv_base + 1
  PHA
  JSR @parse_number
  STA .__work1

  ; read operator char -> .char
  LDA .__argv_base + 2
  STA .__work2          ; pointer to operator token
  LPA .__work2                ; load mem[mem[.__work2]] into A
  STA .char

  ; check if we have three arguments
  LDA .__argv_base
  CPI 3
  JPZ get_second_num
  LDA .char
  JMP check_sqrt        ; if we don't have three numbers, immediately if we're trying to do a square root, skip other operators
get_second_num:
  ; parse second number -> __work2
  LDA .__argv_base + 3
  PHA
  JSR @parse_number
  STA .__work2

  ; dispatch by operator
  LDA .char
  CPI 43              ; '+'
  JPZ do_add
  CPI 45              ; '-'
  JPZ do_sub
  CPI 42              ; '*'
  JPZ do_mul
  CPI 47              ; '/'
  JPZ do_div
  CPI 80              ; 'P'
  JPZ do_pow
check_sqrt:
  CPI 83              ; 'S'
  JPZ do_sqrt
  ; unknown op -> return
  RET

do_add:
  LDA .__work1
  ADD .__work2
  JMP do_print

do_sub:
  LDA .__work1
  SUB .__work2
  JMP do_print_signed

do_sqrt:
  LDA .__work1
  PHA
  JSR @sqrt
  ; Returns values on stack after return (caller *must* pop) -> [ ..., floor(sqrt(n)), residual, gap_to_next_square ]
  PLA           ; gap
  STA .__work3
  PLA           ; residual
  STA .__work4
  PLA           ; result
  JSR @display_number
  JSR @newline
  LDI .residual_text
  JSR print_no_newline
  ; print residual
  LDA .__work4
  JSR @display_number
  JSR @newline
  LDI .distance_text
  JSR print_no_newline
  ; print distance
  LDA .__work3
  JSR @display_number
  JSR @newline
  RET

do_pow:
  LDA .__work1
  PHA
  LDA .__work2
  PHA
  JSR @pow
  JMP do_print

do_mul:
  LDA .__work1
  PHA
  LDA .__work2
  PHA
  JSR @multiply
  JMP do_print

do_div:
  LDA .__work1
  STA .__arg1
  LDA .__work2
  STA .__arg2
  JSR @divide
  ; A holds quotient, .__res2 holds remainder â€” print both
  ; Save quotient and remainder before display_number overwrites .__res2
  STA .__work4          ; save quotient
  LDA .__res2
  STA .__work3          ; save remainder
  LDA .__work4          ; restore quotient
  ; print quotient
  JSR @display_number
  ; print " R "
  LDI 32
  JSR @write_char
  LDI 82              ; 'R'
  JSR @write_char
  LDI 32
  JSR @write_char
  ; print remainder
  LDA .__work3
  JSR @display_number
  JSR @newline
  RET

do_print:
  JSR @display_number
  JSR @newline
  RET

do_print_signed:
  JSR @display_int
  JSR @newline
  RET

; -- print helpers, null terminated. Pointer to text must be in A register --
print_newline:
  PHA
  JSR @printez
  RET

print_no_newline:
  PHA
  LDI 1
  PHA
  LDI 0
  PHA
  JSR @print
  RET