;! name: 3BODYSIM
;! entry: three_body_sim
;! deps: printf, printez, parse_number, q7_8_from_ratio, q7_8_from_dec, q7_8_mul, q7_8_div, display_q7_8, newline, distance2d, toggle_display_enable, display_number, display_q7_8, q7_8_to_int, divide_signed, display_int, divide
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes


;; -- 3 Body Simulation Program --
;; Simulates the motion of three bodies under mutual gravitational attraction.
;; Arguments: <mem_pointer to initial conditions> <time_step> <num_steps>

.usage_1 = "Usage:"
.usage_2 = "3BODYSIM <mem_ptr> <ts> <n_stp>"
.usage_3 = "mem_ptr: ptr to init. conditions"
.usage_4 = "ts: time step in ms (e.g., 10 for 0.01s)"
.usage_5 = "n_stp: number of steps to simulate"

.ic_text_line1 = "Initial Conditions:"
.ic_text_line2 = "A:(%d, %d)  (%f, %f)  %f"
.ic_text_line3 = "B:(%d, %d)  (%f, %f)  %f"
.ic_text_line4 = "C:(%d, %d)  (%f, %f)  %f"
.ic_text_line5 = "G:%f | ts:%f | Steps:%u"
.anykey_text = "Press any key to continue..."

.status_text = "Step %u/%u"
.status_text2 = " A:(%d, %d) (%f, %f)"
.status_text3 = " B:(%d, %d) (%f, %f)"
.status_text4 = " C:(%d, %d) (%f, %f)"
.status_text5 = "Acc A: (%f, %f)"
.status_text6 = "Acc B: (%f, %f)"
.status_text7 = "Acc C: (%f, %f)"
.status_text8 =  "F AB: (%f, %f)"
.status_text9 =  "F AC: (%f, %f)"
.status_text10 = "F BC: (%f, %f)"

.speeds_text1 = "VA: (%f, %f)"
.speeds_text2 = "VB: (%f, %f)"
.speeds_text3 = "VC: (%f, %f)"

a_x = .bss + 0 ; Body A X position
a_y = .bss + 1 ; Body A Y position
a_vx = .bss + 2 ; Body A X velocity
a_vy = .bss + 3 ; Body A Y velocity
a_mass = .bss + 4 ; Body A mass

b_x = .bss + 5 ; Body B X position
b_y = .bss + 6 ; Body B Y position
b_vx = .bss + 7 ; Body B X velocity
b_vy = .bss + 8 ; Body B Y velocity
b_mass = .bss + 9 ; Body B mass

c_x = .bss + 10 ; Body C X position
c_y = .bss + 11 ; Body C Y position
c_vx = .bss + 12 ; Body C X velocity
c_vy = .bss + 13 ; Body C Y velocity
c_mass = .bss + 14 ; Body C mass

gravity_const = .bss + 15 ; Gravitational constant (scaled)
time_step = .bss + 16 ; Time step for simulation
num_steps = .bss + 17 ; Number of simulation steps

a_ax = .bss + 18 ; Body A X acceleration
a_ay = .bss + 19 ; Body A Y acceleration
b_ax = .bss + 20 ; Body B X acceleration
b_ay = .bss + 21 ; Body B Y acceleration
c_ax = .bss + 22 ; Body C X acceleration
c_ay = .bss + 23 ; Body C Y acceleration

step_count = .bss + 24 ; Current step count

load_ptr = .bss + 25 ; Pointer to load initial conditions from memory
load_step = .bss + 26 ; Current step in loading initial conditions
tmp1 = .bss + 27 ; Temporary storage
tmp2 = .bss + 28 ; Temporary storage
tmp3 = .bss + 29 ; Temporary storage
tmp4 = .bss + 30 ; Temporary storage
tmp5 = .bss + 31 ; Temporary storage
tmp6 = .bss + 32 ; Temporary storage
tmp7 = .bss + 33 ; Temporary storage
tmp8 = .bss + 34 ; Temporary storage
tmp9 = .bss + 35 ; Temporary storage
tmp10 = .bss + 36 ; Temporary storage
tmp11 = .bss + 37 ; Temporary storage
tmp12 = .bss + 38 ; Temporary storage
tmp13 = .bss + 39 ; Temporary storage
tmp14 = .bss + 40 ; Temporary storage
tmp15 = .bss + 41 ; Temporary storage

a_b_force_x = .bss + 42 ; Force between A and B (X component)
a_b_force_y = .bss + 43 ; Force between A and B (Y component)
a_c_force_x = .bss + 44 ; Force between A and C (X component)
a_c_force_y = .bss + 45 ; Force between A and C (Y component)
b_c_force_x = .bss + 46 ; Force between B and C (X component)
b_c_force_y = .bss + 47 ; Force between B and C (Y component)

three_body_sim:
  ; Check for correct number of arguments
  LDA .__argv_base
  CPI 3
  JPC tbs_go
    ; Print usage message
  LDI .usage_1
  PHA
  JSR @printez
  LDI .usage_2
  PHA
  JSR @printez
  LDI .usage_3
  PHA
  JSR @printez
  LDI .usage_4
  PHA
  JSR @printez
  LDI .usage_5
  PHA
  JSR @printez
  RET

tbs_go:
  ; Fetch arguments
  LDA .__argv_base + 1
  PHA
  JSR @parse_number
  STA .load_ptr
  
  LDA .__argv_base + 2
  PHA
  JSR @parse_number
  PHA
  LDI 1000
  PHA
  JSR @q7_8_from_ratio
  STA .time_step
  
  LDA .__argv_base + 3
  PHA
  JSR @parse_number
  STA .num_steps

  ; Load initial conditions from memory
  LDI 0
  STA .load_step
tbs_load_loop:
  LDA .load_step
  CPI 16
  JPC tbs_loaded
  LDI .bss            ; bss is start of init conditions
  ADD .load_step
  PHA
  LPA .load_ptr       ; load value from the pointer in load_ptr
  SAS                 ; store in .bss + load_step
  LDA .load_ptr
  ADI 1
  STA .load_ptr
  LDA .load_step
  ADI 1
  STA .load_step
  JMP tbs_load_loop
tbs_loaded:
  ; Print initial conditions
  LDI .ic_text_line1
  PHA
  JSR @printez
  LDI .ic_text_line2
  PHA
  LDI .a_x              ; five initial conditions for body A begin at .a_x
  PHA
  JSR @printf
  LDI .ic_text_line3
  PHA
  LDI .b_x              ; five initial conditions for body B begin at .b_x
  PHA
  JSR @printf
  LDI .ic_text_line4
  PHA
  LDI .c_x              ; five initial conditions for body C begin at .c_x
  PHA
  JSR @printf
  LDI .ic_text_line5
  PHA
  LDI .gravity_const    ; three initial conditions for G, ts and N begin at .gravity_const
  PHA
  JSR @printf
  JSR tbs_wait_any_key

  ; Main simulation loop
  LDI 0
  STA .step_count
  JSR plot_positions
tbs_main_loop:
  LDA .step_count
  CMP .num_steps
  JPC tbs_done
  JSR step
  LDA .step_count
  ADI 1
  STA .step_count
  STA .__arg1
  LDI 10
  STA .__arg2
  JSR @divide
  LDA .__res2
  CPI 1
  JPC tbs_main_loop      ; if remainder >= 1, skip plotting
  JSR plot_positions
  JMP tbs_main_loop

plot_positions:
  ; Plot the three body positions on the LCD.
  ; Assumptions:
  ;   - Positions are signed integers in [-15000, 15000]
  ;   - X axis maps left(-15000)→0 .. right(+15000)→(W-1)
  ;   - Y axis maps up(-15000)→0 .. down(+15000)→(H-1)
  ; Strategy:
  ;   - Clear screen
  ;   - Precompute (W-1) and (H-1) in Q7.8 once
  ;   - For each body, compute:
  ;       col = round( (x + 15000) / 30000 * (W-1) )
  ;       row = round( (15000 - y) / 30000 * (H-1) )
  ;     then move cursor Home, then Down row, Right col, write marker

  ; Clear display
  DIS 1
  JSR @toggle_display_enable
  DIS 8                 ; disable cursor and cursor blink
  JSR @toggle_display_enable

  LDI .speeds_text1
  PHA
  LDI .a_vx
  PHA
  JSR @printf

  LDI .speeds_text2
  PHA
  LDI .b_vx
  PHA
  JSR @printf

  LDI .speeds_text3
  PHA
  LDI .c_vx
  PHA
  JSR @printf

  DIS 2
  JSR @toggle_display_enable

  ; Precompute (W-1) and (H-1) in both int and Q7.8
  LDA .__sys_screen_width
  SUI 1
  STA .tmp12                ; W-1 (int)
  PHA
  LDI 1
  PHA
  JSR @q7_8_from_ratio
  STA .tmp14

  LDA .__sys_screen_height
  SUI 1
  STA .tmp13                ; H-1 (int)
  PHA
  LDI 1
  PHA
  JSR @q7_8_from_ratio
  STA .tmp15

  ; ---- Body A ----
  ; col = round(((a_x+15000)/30000) * (W-1))
  LDA .a_x
  ADI 15000
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp14                ; Q7.8(W-1)
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp9                 ; col
  ; row = round(((15000 - a_y)/30000) * (H-1))
  LDI 15000
  SUB .a_y
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp15                ; Q7.8(H-1)
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp10                ; row
  ; Move cursor home
  DIS 2
  JSR @toggle_display_enable
  ; move down by row
pa_row_loop:
  LDA .tmp10
  CPI 0
  JPZ pa_rows_done
  DIS 20
  JSR @toggle_display_enable
  LDA .tmp10
  SUI 1
  STA .tmp10
  JMP pa_row_loop
pa_rows_done:
  ; move right by col
pa_col_loop:
  LDA .tmp9
  CPI 0
  JPZ pa_cols_done
  DIS 17
  JSR @toggle_display_enable
  LDA .tmp9
  SUI 1
  STA .tmp9
  JMP pa_col_loop
pa_cols_done:
  ; write 'A'
  LDI 65
  JSR @write_char

  ; ---- Body B ----
  ; col
  LDA .b_x
  ADI 15000
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp14
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp9
  ; row
  LDI 15000
  SUB .b_y
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp15
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp10
  ; home and move
  DIS 2
  JSR @toggle_display_enable
pb_row_loop:
  LDA .tmp10
  CPI 0
  JPZ pb_rows_done
  DIS 20
  JSR @toggle_display_enable
  LDA .tmp10
  SUI 1
  STA .tmp10
  JMP pb_row_loop
pb_rows_done:
pb_col_loop:
  LDA .tmp9
  CPI 0
  JPZ pb_cols_done
  DIS 17
  JSR @toggle_display_enable
  LDA .tmp9
  SUI 1
  STA .tmp9
  JMP pb_col_loop
pb_cols_done:
  ; write 'B'
  LDI 66
  JSR @write_char

  ; ---- Body C ----
  ; col
  LDA .c_x
  ADI 15000
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp14
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp9
  ; row
  LDI 15000
  SUB .c_y
  PHA
  LDI 30000
  PHA
  JSR @q7_8_from_ratio
  PHA
  LDA .tmp15
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  STA .tmp10
  ; home and move
  DIS 2
  JSR @toggle_display_enable
pc_row_loop:
  LDA .tmp10
  CPI 0
  JPZ pc_rows_done
  DIS 20
  JSR @toggle_display_enable
  LDA .tmp10
  SUI 1
  STA .tmp10
  JMP pc_row_loop
pc_rows_done:
pc_col_loop:
  LDA .tmp9
  CPI 0
  JPZ pc_cols_done
  DIS 17
  JSR @toggle_display_enable
  LDA .tmp9
  SUI 1
  STA .tmp9
  JMP pc_col_loop
pc_cols_done:
  ; write 'C'
  LDI 67
  JSR @write_char
  RET

print_status:
  LDA .step_count
  STA .tmp10
  LDA .num_steps
  STA .tmp11
  DIS 1                           ; clear display
  JSR @toggle_display_enable
  LDI .status_text
  PHA
  LDI .tmp10
  PHA
  JSR @printf
  LDI .status_text2
  PHA
  LDI .a_x
  PHA
  JSR @printf
  LDI .status_text3
  PHA
  LDI .b_x
  PHA
  JSR @printf
  LDI .status_text4
  PHA
  LDI .c_x
  PHA
  JSR @printf
  LDI .status_text5
  PHA
  LDI .a_ax
  PHA
  JSR @printf
  LDI .status_text6
  PHA
  LDI .b_ax
  PHA
  JSR @printf
  LDI .status_text7
  PHA
  LDI .c_ax
  PHA
  JSR @printf
  LDI .status_text8
  PHA
  LDI .a_b_force_x
  PHA
  JSR @printf
  LDI .status_text9
  PHA
  LDI .a_c_force_x
  PHA
  JSR @printf
  LDI .status_text10
  PHA
  LDI .b_c_force_x
  PHA
  JSR @printf
  RET

step:
  ; Calculate accelerations based on current positions
  JSR calculate_accelerations

  ; Update velocities based on accelerations and time step
  ; vx = vx + ax * dt
  LDA .a_ax
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA                     ; delta = ax*dt
  LDA .a_vx               ; current vx
  PHA
  JSR sat_add_speed_q78   ; saturated add to [-128,128)
  STA .a_vx

  LDA .a_ay
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  LDA .a_vy
  PHA
  JSR sat_add_speed_q78
  STA .a_vy

  LDA .b_ax
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  LDA .b_vx
  PHA
  JSR sat_add_speed_q78
  STA .b_vx

  LDA .b_ay
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  LDA .b_vy
  PHA
  JSR sat_add_speed_q78
  STA .b_vy

  LDA .c_ax
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  LDA .c_vx
  PHA
  JSR sat_add_speed_q78
  STA .c_vx

  LDA .c_ay
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  LDA .c_vy
  PHA
  JSR sat_add_speed_q78
  STA .c_vy

  ; Update positions based on velocities and time step. Position is integer and velocity is Q7.8, so just add integer part of velocity.
  ; x = x + vx * dt
  LDA .a_vx
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .a_x
  JSR clamp_pos_in_A
  STA .a_x

  LDA .a_vy
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .a_y
  JSR clamp_pos_in_A
  STA .a_y

  LDA .b_vx
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .b_x
  JSR clamp_pos_in_A
  STA .b_x

  LDA .b_vy
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .b_y
  JSR clamp_pos_in_A
  STA .b_y

  LDA .c_vx
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .c_x
  JSR clamp_pos_in_A
  STA .c_x

  LDA .c_vy
  PHA
  LDA .time_step
  PHA
  JSR @q7_8_mul
  PHA
  JSR @q7_8_to_int
  ADD .c_y
  JSR clamp_pos_in_A
  STA .c_y

  RET

; Saturating add for speeds: returns clamp(current + delta) to [-128, 128)
; args ABI: push current; push delta; JSR sat_add_speed_q78
; Returns: A = saturated sum
sat_add_speed_q78:
  ; Prologue: fetch args (top = delta, next = current)
  PLA
  MOVAB
  PLA
  STA .tmp9           ; delta
  PLA
  STA .tmp10          ; current
  MOVBA
  PHA
  ; Build sign mask in .tmp11
  LDI 1
  STA .tmp11
  LDA .__sys_bits_avail
  SUI 1
  STA .tmp12
sat_mask_loop:
  LDA .tmp12
  CPI 0
  JPZ sat_mask_done
  LDA .tmp11
  LSA
  STA .tmp11
  LDA .tmp12
  SUI 1
  STA .tmp12
  JMP sat_mask_loop
sat_mask_done:
  ; sign_delta -> .tmp12 (0/1)
  LDA .tmp9
  CMP .tmp11
  JPC sat_d_neg
  LDI 0
  STA .tmp12
  JMP sat_c_sign
sat_d_neg:
  LDI 1
  STA .tmp12
sat_c_sign:
  ; sign_current -> .tmp15 (0/1)
  LDA .tmp10
  CMP .tmp11
  JPC sat_c_neg
  LDI 0
  STA .tmp15
  JMP sat_do_add
sat_c_neg:
  LDI 1
  STA .tmp15
sat_do_add:
  ; sum = delta + current
  LDA .tmp9
  ADD .tmp10
  STA .tmp13          ; sum (mod word)
  ; sign_sum -> .tmp14
  LDA .tmp13
  CMP .tmp11
  JPC sat_s_neg
  LDI 0
  STA .tmp14
  JMP sat_chk_ovf
sat_s_neg:
  LDI 1
  STA .tmp14
sat_chk_ovf:
  ; overflow if (sign_delta == sign_current) && (sign_sum != sign_delta)
  LDA .tmp12
  CMP .tmp15
  JPZ sat_signs_equal
  JMP sat_no_ovf
sat_signs_equal:
  ; if sign_sum != sign_delta -> overflow
  LDA .tmp14
  CMP .tmp12
  JPZ sat_no_ovf
  ; OVERFLOW -> saturate to boundary by sign of operands (sign_delta)
  LDA .tmp12
  CPI 0
  JPZ sat_pos_sat
  ; negative overflow -> -128.0
  LDI 0
  SUI 32768
  RET
sat_pos_sat:
  ; positive overflow -> +127.996 (~0x7FFF)
  LDI 32767
  RET
sat_no_ovf:
  ; No signed overflow: clamp to [-128, 128)
  LDA .tmp13
  JSR clamp_speed_q78_in_A
  RET

; Clamp Q7.8 value in A to the range [-128, 128)
; Uses temporaries: .tmp9 (val), .tmp10 (sign_mask), .tmp11 (cnt), .tmp12 (abs), .tmp13 (ip)
clamp_speed_q78_in_A:
  ; save original value
  STA .tmp9
  ; build sign mask = 1 << (.__sys_bits_avail - 1)
  LDI 1
  STA .tmp10
  LDA .__sys_bits_avail
  SUI 1
  STA .tmp11
clmp_mask_loop:
  LDA .tmp11
  CPI 0
  JPZ clmp_mask_done
  LDA .tmp10
  LSA
  STA .tmp10
  LDA .tmp11
  SUI 1
  STA .tmp11
  JMP clmp_mask_loop
clmp_mask_done:
  ; abs(value)
  LDA .tmp9
  CMP .tmp10
  JPC clmp_neg
  STA .tmp12
  JMP clmp_abs_done
clmp_neg:
  LDI 0
  SUB .tmp9
  STA .tmp12
clmp_abs_done:
  ; ip = abs(value) >> 8
  LDA .tmp12
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .tmp13
  ; if ip >= 128 then clamp
  LDA .tmp13
  CPI 128
  JPC clmp_do
  ; else return original
  LDA .tmp9
  RET
clmp_do:
  ; choose min/max based on original sign
  LDA .tmp9
  CMP .tmp10
  JPC clmp_set_min
  ; positive overflow -> set to +127.996 (~0x7FFF)
  LDI 32767
  RET
clmp_set_min:
  ; negative overflow -> set to -128.0 (-(128<<8) = -32768)
  LDI 0
  SUI 32768
  RET

; Clamp integer position in A to [-15000, 15000]
; Uses temporaries: .tmp9 (val), .tmp10 (sign_mask), .tmp11 (cnt), .tmp12 (abs)
clamp_pos_in_A:
  STA .tmp9
  ; build sign mask
  LDI 1
  STA .tmp10
  LDA .__sys_bits_avail
  SUI 1
  STA .tmp11
clp_mask_loop:
  LDA .tmp11
  CPI 0
  JPZ clp_mask_done
  LDA .tmp10
  LSA
  STA .tmp10
  LDA .tmp11
  SUI 1
  STA .tmp11
  JMP clp_mask_loop
clp_mask_done:
  ; if negative
  LDA .tmp9
  CMP .tmp10
  JPC clp_is_neg
  ; non-negative: if A >= 15000 -> clamp to 15000
  LDA .tmp9
  CPI 15000
  JPC clp_pos_sat
  ; else return original
  LDA .tmp9
  RET
clp_pos_sat:
  LDI 15000
  RET
clp_is_neg:
  ; abs = -val
  LDI 0
  SUB .tmp9
  STA .tmp12
  ; if abs >= 15000 -> clamp to -15000
  LDA .tmp12
  CPI 15000
  JPC clp_neg_sat
  ; else return original
  LDA .tmp9
  RET
clp_neg_sat:
  LDI 0
  SUI 15000
  RET

calculate_accelerations:
  ; Reset accelerations to zero
  LDI 0
  STA .a_ax
  STA .a_ay
  STA .b_ax
  STA .b_ay
  STA .c_ax
  STA .c_ay

  ; Calculate distance between A and B
  LDA .a_x
  PHA
  LDA .a_y
  PHA
  LDA .b_x
  PHA
  LDA .b_y
  PHA
  JSR @distance2d
  RSA                  ; right shift 8 times (divide by 256) to scale down
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  CPI 2
  JPC dist_ab_ok
  LDI 2
dist_ab_ok:
  STA .tmp1            ; tmp1 = distance AB
  LDI 1
  PHA
  LDA .tmp1
  PHA
  JSR @q7_8_from_ratio
  STA .tmp12           ; tmp12 = 1/d_AB
  ; Calculate force magnitude between A and B: F = G * m1 * m2
  LDA .a_mass
  PHA
  LDA .b_mass
  PHA
  JSR @q7_8_mul
  PHA
  LDA .gravity_const
  PHA
  JSR @q7_8_mul
  STA .tmp2            ; tmp2 = force magnitude AB
  ; Calculate distance between A and C
  LDA .a_x
  PHA
  LDA .a_y
  PHA
  LDA .c_x
  PHA
  LDA .c_y
  PHA
  JSR @distance2d
  RSA                  ; right shift 8 times (divide by 256) to scale down
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  CPI 2
  JPC dist_ac_ok
  LDI 2
dist_ac_ok:
  STA .tmp3            ; tmp3 = distance AC
  LDI 1
  PHA
  LDA .tmp3
  PHA
  JSR @q7_8_from_ratio
  STA .tmp13           ; tmp13 = 1/d_AC
  ; Calculate force magnitude between A and C: F = G * m1 * m2
  LDA .a_mass
  PHA
  LDA .c_mass
  PHA
  JSR @q7_8_mul
  PHA
  LDA .gravity_const
  PHA
  JSR @q7_8_mul
  STA .tmp4            ; tmp4 = force magnitude AC
  ; Calculate distance between B and C
  LDA .b_x
  PHA
  LDA .b_y
  PHA
  LDA .c_x
  PHA
  LDA .c_y
  PHA
  JSR @distance2d
  RSA                  ; right shift 8 times (divide by 256) to scale down
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  CPI 2
  JPC dist_bc_ok
  LDI 2
dist_bc_ok:
  STA .tmp5            ; tmp5 = distance BC
  LDI 1
  PHA
  LDA .tmp5
  PHA
  JSR @q7_8_from_ratio
  STA .tmp14           ; tmp14 = 1/d_BC
  ; Calculate force magnitude between B and C: F = G * m1 * m2
  LDA .b_mass
  PHA
  LDA .c_mass
  PHA
  JSR @q7_8_mul
  PHA
  LDA .gravity_const
  PHA
  JSR @q7_8_mul
  STA .tmp6            ; tmp6 = force magnitude BC

  ; Calculate a_ax
  ; a_ax = (F_AB * (bx - ax) / d_AB³ + F_AC * (cx - ax) / d_AC³) / m_a
  ; build fraction (bx - ax) / d_AB³
  LDA .b_x
  SUB .a_x
  PHA
  LDA .tmp1
  PHA                                  ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (bx - ax) / d_AB
  LDA .tmp1
  PHA
  JSR @q7_8_from_ratio
  PHA   ; (bx - ax) / d_AB²
  LDA .tmp12
  PHA                                   ; use precomputed 1/d_AB
  JSR @q7_8_mul
  PHA   ; (bx - ax) / d_AB³
  ; multiply by force magnitude F_AB
  LDA .tmp2
  PHA
  JSR @q7_8_mul
  STA .a_b_force_x                      ; F_AB * (bx - ax) / d_AB³ (force on A due to B)
  ; build fraction (cx - ax) / d_AC³
  LDA .c_x
  SUB .a_x
  PHA
  LDA .tmp3
  PHA                                  ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (cx - ax) / d_AC
  LDA .tmp3
  PHA
  JSR @q7_8_from_ratio 
  PHA   ; (cx - ax) / d_AC²
  LDA .tmp13
  PHA
  JSR @q7_8_mul
  PHA   ; (cx - ax) / d_AC³
  ; multiply by force magnitude F_AC
  LDA .tmp4
  PHA
  JSR @q7_8_mul
  STA .a_c_force_x                      ; F_AC * (cx - ax) / d_AC³
  ; add contributions and divide by mass
  ADD .a_b_force_x                      ; a_c_force_x already in A, a_b_force_x + a_c_force_x
  PHA
  LDA .a_mass
  PHA
  JSR @q7_8_div
  STA .a_ax

  ; Calculate a_ay
  ; a_ay = (F_AB * (by - ay) / d_AB³ + F_AC * (cy - ay) / d_AC³) / m_a
  ; build fraction (by - ay) / d_AB³
  LDA .b_y
  SUB .a_y
  PHA
  LDA .tmp1
  PHA                                  ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (by - ay) / d_AB
  LDA .tmp1
  PHA
  JSR @q7_8_from_ratio 
  PHA   ; (by - ay) / d_AB²
  LDA .tmp12
  PHA
  JSR @q7_8_mul
  PHA   ; (by - ay) / d_AB³
  ; multiply by force magnitude F_AB
  LDA .tmp2
  PHA
  JSR @q7_8_mul
  STA .a_b_force_y                      ; F_AB * (by - ay) / d_AB³
  ; build fraction (cy - ay) / d_AC³
  LDA .c_y
  SUB .a_y
  PHA
  LDA .tmp3
  PHA                                  ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (cy - ay) / d_AC
  LDA .tmp3
  PHA
  JSR @q7_8_from_ratio 
  PHA   ; (cy - ay) / d_AC²
  LDA .tmp13
  PHA
  JSR @q7_8_mul
  PHA   ; (cy - ay) / d_AC³
  ; multiply by force magnitude F_AC
  LDA .tmp4
  PHA
  JSR @q7_8_mul
  STA .a_c_force_y                      ; F_AC * (cy - ay) / d_AC³
  ; add contributions and divide by mass
  ADD .a_b_force_y                      ; a_c_force_y already in A, a_b_force_y + a_c_force_y
  PHA
  LDA .a_mass
  PHA
  JSR @q7_8_div
  STA .a_ay

  ; Calculate b_ax
  ; b_ax = (F_AB * (ax - bx) / d_AB³ + F_BC * (cx - bx) / d_BC³) / m_b

  ; build fraction (ax - bx) / d_AB³ = - F_AB * (bx - ax) / d_AB³ = -.a_b_force_x
  LDI 0
  SUB .a_b_force_x
  STA .tmp7                                 ; tmp7 = b_a_force_x = F_AB * (ax - bx) / d_AB³
  
  ; build fraction (cx - bx) / d_BC³
  LDA .c_x
  SUB .b_x
  PHA
  LDA .tmp5
  PHA                                   ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (cx - bx) / d_BC
  LDA .tmp5
  PHA
  JSR @q7_8_from_ratio 
  PHA   ; (cx - bx) / d_BC²
  LDA .tmp14
  PHA
  JSR @q7_8_mul
  PHA   ; (cx - bx) / d_BC³
  ; multiply by force magnitude F_BC
  LDA .tmp6
  PHA
  JSR @q7_8_mul
  STA .b_c_force_x                       ; F_BC * (cx - bx) / d_BC³
  ; add contributions and divide by mass
  ADD .tmp7                                 ; b_c_force_x already in A, b_a_force_x + b_c_force_x
  PHA
  LDA .b_mass
  PHA
  JSR @q7_8_div
  STA .b_ax

  ; Calculate b_ay
  ; b_ay = (F_AB * (ay - by) / d_AB³ + F_BC * (cy - by) / d_BC³) / m_b

  ; build fraction (ay - by) / d_AB³ = - F_AB * (by - ay) / d_AB³ = -.a_b_force_y
  LDI 0
  SUB .a_b_force_y
  STA .tmp7                                 ; tmp7 = b_a_force_y = F_AB * (ay - by) / d_AB³

  ; build fraction (cy - by) / d_BC³
  LDA .c_y
  SUB .b_y
  PHA
  LDA .tmp5
  PHA                                  ; do the first division as integer division to avoid decimal overflow
  JSR @divide_signed
  PHA   ; (cy - by) / d_BC
  LDA .tmp5
  PHA
  JSR @q7_8_from_ratio 
  PHA   ; (cy - by) / d_BC²
  LDA .tmp14
  PHA
  JSR @q7_8_mul
  PHA   ; (cy - by) / d_BC³
  ; multiply by force magnitude F_BC
  LDA .tmp6
  PHA
  JSR @q7_8_mul
  STA .b_c_force_y                      ; F_BC * (cy - by) / d_BC³
  ; add contributions and divide by mass
  ADD .tmp7                                 ; b_c_force_y already in A, b_a_force_y + b_c_force_y
  PHA
  LDA .b_mass
  PHA
  JSR @q7_8_div
  STA .b_ay

  ; Calculate c_ax
  ; c_ax = (F_AC * (ax - cx) / d_AC³ + F_BC * (bx - cx) / d_BC³) / m_c
  ; build fraction (ax - cx) / d_AC³ = - F_AC * (cx - ax) / d_AC³ = -.a_c_force_x
  LDI 0
  SUB .a_c_force_x
  STA .tmp7                                 ; tmp7 = c_a_force_x = F_AC * (ax - cx) / d_AC³
  ; build fraction (bx - cx) / d_BC³ = - F_BC * (cx - bx) / d_BC³ = -.b_c_force_x
  LDI 0
  SUB .b_c_force_x
  STA .tmp8                                 ; tmp8 = c_b_force_x = F_BC * (bx - cx) / d_BC³
  ; add contributions and divide by mass
  ADD .tmp7                                 ; c_a_force_x + c_b_force_x
  PHA
  LDA .c_mass
  PHA
  JSR @q7_8_div
  STA .c_ax

  ; Calculate c_ay
  ; c_ay = (F_AC * (ay - cy) / d_AC³ + F_BC * (by - cy) / d_BC³) / m_c
  ; build fraction (ay - cy) / d_AC³ = - F_AC * (cy - ay) / d_AC³ = -.a_c_force_y
  LDI 0
  SUB .a_c_force_y
  STA .tmp7                                 ; tmp7 = c_a_force_y = F_AC * (ay - cy) / d_AC³
  ; build fraction (by - cy) / d_BC³ = - F_BC * (cy - by) / d_BC³ = -.b_c_force_y
  LDI 0
  SUB .b_c_force_y
  STA .tmp8                                 ; tmp8 = c_b_force_y = F_BC * (by - cy) / d_BC³
  ; add contributions and divide by mass
  ADD .tmp7                                 ; c_a_force_y + c_b_force_y
  PHA
  LDA .c_mass
  PHA
  JSR @q7_8_div
  STA .c_ay

  RET

; Wait for any key press
tbs_wait_any_key:
  LDI .anykey_text
  PHA
  JSR @printez
wait_loop:
  KEI
  CPI 128
  JPC wait_done
  JMP wait_loop
wait_done:
  RET

tbs_done:
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR @toggle_display_enable 
  DIS 15            ; set on, display cursor, cursor blink
  JSR @toggle_display_enable
  DIS 1
  JSR @toggle_display_enable
  JSR @newline
  RET