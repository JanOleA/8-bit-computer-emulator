;! name: PUZZLE
;! entry: main
;! deps: multiply, divide, sqrt, rem64, addsq64, display_number, newline
;! abi: os
;! bss: auto
;! align: 20

bss         ; check_value
bss + 1     ; loop_index
bss + 2     ; half_check
bss + 3     ; square_val
bss + 4     ; square_result
bss + 5     ; square_sum
bss + 6     ; num_primes
bss + 7     ; finds
; Extended 64-bit sum storage
bss + 8     ; sum_lo
bss + 9     ; sum_hi

main:
  LDI 4
  STA .bss + 8       ; sum_lo = 4 (2^2)
  LDI 0
  STA .bss + 9       ; sum_hi = 0
  LDI 3
  STA .bss    
  LDI 1
  STA .bss + 6
  LDI 232
  STA .bss + 7
main_loop:
  JSR check_prime_os
  CPI 0
  JPZ next_val
its_prime:
  LDA .bss + 6
  ADI 1
  STA .bss + 6
  OUT
  CPI 600
  JPC done
  ; add n^2 into 64-bit sum at (sum_lo,sum_hi)
  LDA .bss
  STA .arg1              ; p
  LDI .bss               ; base of bss
  ADI 8
  STA .arg2              ; &sum_lo
  LDI .bss
  ADI 9
  STA .res1              ; &sum_hi
  JSR @add_square64
  ; (sum of squares) % (#primes) == 0 ?
  ; remainder = (sum_hi:sum_lo) % num_primes
  LDI .bss
  ADI 8
  PHA
  LAS
  STA .arg1              ; lo
  LDI .bss
  ADI 9
  PHA
  LAS
  STA .arg2              ; hi
  LDA .bss + 6
  STA .res1              ; mod = num_primes
  JSR @rem64
  ; A holds remainder
  CPI 0
  JPZ found_one
  JMP next_val
found_one:
  ; print bss + 6
  LDA .bss + 6
  STA .arg1
  JSR @display_number
  JSR @newline
  ; store bss + 6 at *(bss + 7); then increment pointer
  LDA .bss + 7
  PHA
  LDA .bss + 6
  SAS
  LDA .bss + 7
  ADI 1
  STA .bss + 7
next_val:
  LDA .bss
  ADI 2
  STA .bss    
  JMP main_loop

; primality test using OS divide; returns A=1 if prime else A=0
check_prime_os:
  ; limit divisor up to floor(sqrt(n)) for fewer trials
  LDA .bss
  STA .arg1
  JSR @sqrt
  STA .bss + 2        ; sqrt_n
  LDI 3
  STA .bss + 1
prime_loop_os:
  ; if divisor > sqrt_n → prime; if divisor == sqrt_n → still test divisibility
  LDA .bss + 1        ; divisor
  CMP .bss + 2        ; compare to sqrt_n
  JPC pl_check_eq     ; carry set when divisor >= sqrt_n
  JMP pl_do_div       ; divisor < sqrt_n → test
pl_check_eq:
  JPZ pl_do_div       ; equal → still test divisibility by sqrt_n
  JMP prime_os        ; strictly greater → prime
pl_do_div:
  LDA .bss            ; n
  STA .arg1
  LDA .bss + 1        ; divisor
  STA .arg2
  JSR @divide
  LDA .res2
  CPI 0
  JPZ not_prime_os
  LDA .bss + 1
  ADI 2
  STA .bss + 1
  JMP prime_loop_os
not_prime_os:
  LDI 0
  RET
prime_os:
  LDI 1
  RET
done:
  RET
