;! name: PUZZLE
;! entry: main
;! deps: multiply, divide, sqrt, rem64, addsq64, display_number, newline
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes

; Find values of n so that if you take the first n primes, square them, then sum them, and if that value is a multiple of n. Then n is a valid solution.

bss         ; check_value
bss + 1     ; loop_index
bss + 2     ; half_check
bss + 3     ; square_val
bss + 4     ; square_result
bss + 5     ; square_sum
bss + 6     ; num_primes
bss + 7     ; finds
; Extended 64-bit sum storage
bss + 8     ; sum_lo
bss + 9     ; sum_hi

main:
  LDI 4
  STA .bss + 8       ; sum_lo = 4 (2^2)
  LDI 0
  STA .bss + 9       ; sum_hi = 0
  LDI 3
  STA .bss    
  LDI 1
  STA .bss + 6
  LDI 232
  STA .bss + 7
main_loop:
  JSR check_prime_os
  CPI 0
  JPZ next_val
its_prime:
  LDA .bss + 6
  ADI 1
  STA .bss + 6
  OUT
  ; add n^2 into 64-bit sum at (sum_lo,sum_hi)
  LDA .bss
  STA .__arg1              ; p
  LDI .bss               ; base of bss
  ADI 8
  STA .__arg2              ; &sum_lo
  LDI .bss
  ADI 9
  STA .__res1              ; &sum_hi
  JSR @add_square64
  ; (sum of squares) % (#primes) == 0 ?
  ; remainder = (sum_hi:sum_lo) % num_primes
  LDA .bss + 8
  STA .__arg1              ; lo
  LDA .bss + 9
  STA .__arg2              ; hi
  LDA .bss + 6
  STA .__res1              ; mod = num_primes
  JSR @rem64
  ; A holds remainder
  CPI 0
  JPZ found_one
  JMP next_val
found_one:
  ; print bss + 6
  LDA .bss + 6
  JSR @display_number
  JSR @newline
  ; store bss + 6 at *(bss + 7); then increment pointer
  LDA .bss + 7
  PHA
  LDA .bss + 6
  SAS
  LDA .bss + 7
  ADI 1
  STA .bss + 7
next_val:
  LDA .bss
  ADI 2
  STA .bss    
  JMP main_loop

; primality test using OS divide; returns A=1 if prime else A=0
check_prime_os:
  ; Trial division with incremental square to avoid sqrt and multiply
  LDI 3
  STA .bss + 1        ; divisor d = 3
  LDI 9
  STA .bss + 2        ; square = d*d = 9
prime_loop_os:
  ; if square > n → prime; if square == n → still test divisibility by d
  LDA .bss + 2        ; square
  CMP .bss            ; compare to n
  JPC pl_square_ge
  ; square < n → test divisibility by d
pl_do_div:
  LDA .bss            ; n
  STA .__arg1
  LDA .bss + 1        ; divisor d
  STA .__arg2
  JSR @divide
  LDA .__res2
  CPI 0
  JPZ not_prime_os
  ; advance d by 2 and square by 4d + 4 (using old d)
  LDA .bss + 1        ; old d
  LSA
  LSA                 ; 4d
  ADI 4               ; 4d + 4
  ADD .bss + 2        ; square += 4d + 4
  STA .bss + 2
  LDA .bss + 1
  ADI 2
  STA .bss + 1
  JMP prime_loop_os
pl_square_ge:
  JPZ pl_do_div       ; if square == n, test divisibility
  JMP prime_os        ; square > n → prime
not_prime_os:
  LDI 0
  RET
prime_os:
  LDI 1
  RET
done:
  RET
