;! name: CAT
;! entry: cat
;! deps: write_char, newline, parse_number, skip_line
;! abi: all
;! bss: auto
;! align: 4

; --- Print the contents of memory as text, until first null terminator. \ (ASCII 92) as well as certain special values works as escape character. ---
; -- escape characters overview
; \n            - newline
; \\            - \
; 0x0A (10)     - newline

; if an argument is provided, interpret it as initial memory address
; if not, use value in .arg1 as initial memory address and .arg2 as max lines (0 = all)
; .res1 on input is whether to truncate lines (1=truncate, else=wrap)
; 
; -- .res1 = number of characters that were printed. .res2 = number of newlines that were printed --

escape_mode = bss + 0           ; 1 if we are in escape mode
chars_printed = bss + 1         ; chars printed on current line
total_chars_printed = bss + 2   ; total number of printed characters
newlines_printed = bss + 3      ; number of printed newlines
max_lines = bss + 4             ; max lines
truncate_lines = bss + 5        ; If 1 truncate lines, else wrap

screen_width = 40               ; screen width in characters

cat:
  LDI 0
  STA .escape_mode
  STA .chars_printed
  STA .total_chars_printed
  LDI 1
  STA .newlines_printed          ; there will always be at least one newline (end of program)
  LDA .argv_base
  CPI 0
  JPZ print_init
  LDA .argv_base + 1
  PHA
  JSR @parse_number
  STA .arg1
  LDI 0
  STA .arg2
  STA .res1
print_init:
  LDA .res1
  STA .truncate_lines
  LDA .arg2
  STA .max_lines
print_loop:
  LPA .arg1                ; load mem[mem[.arg1]] into A
  STA .char
  CPI 0
  JPZ end
  LDA .escape_mode              ; check if we are in escape mode
  CPI 1
  JPZ escape_char
  LDA .char
  CPI 92
  JPZ set_escape
  LDA .char
  CPI 10                ; literal newline (0x0A)
  JPZ escape_newline
  JSR write_char_wrapper
  JMP advance

set_escape:
  LDI 1
  STA .escape_mode
  JMP advance

escape_char:            ; -- handle escape characters
  LDI 0
  STA .escape_mode              ; reset escape mode
  LDA .char
  CPI 92                ; \, print it
  JPZ escape_backslash
  CPI 78                ; N, newline
  JPZ escape_newline
  ; -- no known escape, just print the character
escape_backslash:           ; same for backslash
  JSR write_char_wrapper
  JMP advance
escape_newline:
  LDI 0
  STA .chars_printed
  LDA .newlines_printed
  ADI 1                 ; increment number of newlines printed
  STA .newlines_printed
  CMP .max_lines
  JPC check_max_lines
  JMP pass_check_max_lines
check_max_lines:
  LDA .max_lines
  CPI 0
  JPZ pass_check_max_lines
  JMP end
pass_check_max_lines:
  JSR @newline
advance:                ; -- advance the pointer by one, also makes a newline if we have printed >= screen_width number of characters, jump to start of loop
  LDA .arg1
  ADI 1
  STA .arg1
  LDA .chars_printed
  CPI .screen_width     ; if printed characters >= screen width, make a new line
  JPC wrap_or_truncate
  JMP print_loop        ; continue main loop if line not full
wrap_or_truncate:
  LDA .truncate_lines
  CPI 1
  JPZ truncate
  JMP newline_helper
truncate:
  JSR @skip_line
  LDA .res1
  ADD .total_chars_printed
  STA .total_chars_printed
  LDA .arg1
  SUI 1                       ; Compensate for upcoming advance which always increments .arg1; skip_line returns next-line start so step back 1 here so the shared advance landing position is correct.
  STA .arg1
  JMP escape_newline
newline_helper:         ; -- write a newline, but also set the characters printed on current line to 0
  LDI 0
  STA .chars_printed
  JSR @newline
  JMP print_loop

write_char_wrapper:     ; -- Subroutine. Write character (in .char) and increment characters printed on current line (and total)
  JSR @write_char
  LDA .chars_printed
  ADI 1
  STA .chars_printed
  LDA .total_chars_printed
  ADI 1
  STA .total_chars_printed
  RET

end:
  LDA .total_chars_printed
  STA .res1
  LDA .newlines_printed
  STA .res2
  JSR @newline
  RET