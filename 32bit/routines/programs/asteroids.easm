;! name: ASTEROIDS
;! entry: main
;! deps: randint, write_char, newline, display_number, echon, wait_100
;! abi: os
;! bss: auto
;! align: 4

screen_width = 39
screen_height = 20
repeat_delay = 64       ; ticks before first auto-repeat
repeat_shift = 4        ; repeat rate = every 2^repeat_shift ticks after delay

.score_text = "SCORE: "
.game_over_text = "Game over! Your final score: "
.asteroid_symbol = "O"
.turret_symbol = "A"
.bullet_symbol = "|"

; bss + 0     : turret position
; bss + 1     : asteroid X
; bss + 2     : asteroid Y
; bss + 3     : current line
; bss + 4     : X tmp
; bss + 5     : bullet X
; bss + 6     : bullet fired
; bss + 7     : input entered
; bss + 8     : entered value
; bss + 9     : score
; bss + 10    : last_key (for repeat)
; bss + 11    : hold_count (for repeat)

main:
  DIS 8                 ; disable cursor and cursor blink
  JSR screen_instruction
  JSR clear_display
  LDI .screen_width
  STA .arg1
  JSR @randint
  LDA .res1             ; get random value in [0,40)
  STA .bss              ; turret position
  LDI 1
  STA .bss + 3          ; current line we are drawing
  LDI 0
  STA .bss + 9          ; score

new_asteroid:
  LDI .screen_width
  STA .arg1
  JSR @randint
  LDA .res1             ; get random value in [0,40)
  STA .bss + 1          ; asteroid X position
  LDI 0
  STA .bss + 2          ; asteroid Y position
game_loop:
  LDI 0
  STA .bss + 6          ; bullet fired
  JSR update_display
  JSR wait_3200
  LDA .bss + 9
  CPI 50
  JPC skip_waits
  JSR update_display
  JSR wait_3200
  LDA .bss + 9
  CPI 25
  JPC skip_waits
  JSR update_display
  JSR wait_3200
  LDA .bss + 9
  CPI 10
  JPC skip_waits
  JSR update_display
  JSR wait_3200
skip_waits:
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  CPI .screen_height
  JPC end
  LDA .bss + 6        ; = bullet fired
  CPI 0
  JPZ game_loop 
  JSR update_display
  JSR wait_3200
  LDA .bss + 5
  CMP .bss + 1
  JPZ hit
  JMP game_loop
hit:
  LDA .bss + 9
  ADI 1
  STA .bss + 9
  JMP new_asteroid

update_display:
  JSR clear_display
  ; print "SCORE: " without newline
  LDI .score_text
  STA .arg1
  JSR print_z
  LDA .bss + 9
  STA .arg1
  JSR @display_number
  JSR @newline
  LDI 1
  STA .bss + 3
screen_loop:
  LDA .bss + 3                  ; current line we are drawing
  CMP .bss + 2
  JPZ write_asteroid_wrapper
  JSR write_bullet
  JSR @newline
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  CPI .screen_height
  JPC write_turret_wrapper
  JMP screen_loop
write_turret_wrapper:
  JSR write_turret
  RET

write_bullet:
  LDA .bss + 6
  CPI 0
  JPZ ret_immediate         ; return immediately if bullet is not fired
  LDA .bss + 2
  ADI 1
  CMP .bss + 3
  JPZ ret_immediate         ; return immediately if we're on the same line as the asteroid
  LDA .bss + 5
  CMP .bss + 1
  JPZ test_bullet_y
  JMP begin_write_bullet
test_bullet_y:
  LDA .bss + 2
  CMP .bss + 3
  JPC ret_immediate
begin_write_bullet:
  LDA .bss + 5              ; store position in tmp
  STA .bss + 4
write_bullet_loop:
  LDA .bss + 5
  CPI 0
  JPZ write_bullet_end
  JSR advance_cursor
  LDA .bss + 5
  SUI 1
  STA .bss + 5
  JMP write_bullet_loop
write_bullet_end:
  LDA .bullet_symbol
  STA .char
  JSR @write_char
  LDA .bss + 4
  STA .bss + 5              ; get position back from tmp
ret_immediate:
  RET

write_asteroid_wrapper:
  JSR write_asteroid
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  JMP screen_loop

write_asteroid:
  LDI 0
  STA .bss + 4              ; use tmp as pointer
write_asteroid_loop:
  LDA .bss + 1
  CMP .bss + 4
  JPZ write_asteroid_character
  JMP check_bullet
write_asteroid_character:
  LDA .asteroid_symbol
  STA .char
  JSR @write_char
  JMP skip_advance
check_bullet:
  LDA .bss + 6
  CPI 0                     ; if bullet fired is zero
  JPZ advance_asteroid_line ; skip
  LDA .bss + 5
  CMP .bss + 4
  JPZ write_bullet_character
  JMP advance_asteroid_line
write_bullet_character:
  LDA .bullet_symbol
  STA .char
  JSR @write_char
  JMP skip_advance
advance_asteroid_line:
  JSR advance_cursor
skip_advance:
  LDA .bss + 4
  CPI .screen_width
  JPC write_asteroid_end
  ADI 1
  STA .bss + 4
  JMP write_asteroid_loop
write_asteroid_end:
  RET

write_turret:
  LDA .bss                  ; store position in tmp
  STA .bss + 4
write_turret_loop:
  LDA .bss
  CPI 0
  JPZ write_turret_end
  JSR advance_cursor
  LDA .bss
  SUI 1
  STA .bss
  JMP write_turret_loop
write_turret_end:
  LDA .turret_symbol
  STA .char
  JSR @write_char
  LDA .bss + 4
  STA .bss                  ; get position back from tmp
  RET

wait_3200:
  JSR wait_1600
  JSR wait_1600
  RET

wait_1600:
  JSR wait_800
  JSR wait_800
  RET

wait_800:
  JSR wait_400
  JSR wait_400
  RET

wait_400:
  JSR wait_200
  JSR wait_200
  RET

wait_200:
  JSR wait_100
  JSR wait_100
  RET

wait_100:
  JSR check_input
  LDA .bss + 7
  CPI 0
  JPZ set_no_input
  ; --- Key repeat handling ---
  ; If same key is still held, increment hold_count and allow repeats after a delay.
  ; Generate repeats when hold_count >= repeat_delay and only every 2^repeat_shift ticks thereafter.
  LDA .bss + 8
  CMP .bss + 10
  JPZ same_key_held
  ; New key pressed: remember it, reset hold_count, and allow handling
  LDA .bss + 8
  STA .bss + 10       ; last_key = current
  LDI 0
  STA .bss + 11       ; hold_count = 0
  LDI 0
  STA .no_input       ; ensure this press is handled now
  JMP after_repeat_gate
same_key_held:
  LDA .bss + 11
  ADI 1
  STA .bss + 11       ; ++hold_count
  ; if hold_count >= repeat_delay and at a gated interval -> clear no_input to allow repeat
  CPI .repeat_delay
  JPC chk_rate        ; carry set when A >= 64
  JMP after_repeat_gate
chk_rate:
  ; allow repeat only when hold_count is a multiple of 2^repeat_shift:
  ; ((n >> repeat_shift) << repeat_shift) == n
  ; Save original n in work3
  LDA .bss + 11
  STA .work3
  ; work1 = n
  LDA .work3
  STA .work1
  ; work2 = repeat_shift (right shift count)
  LDI .repeat_shift
  STA .work2
crs_loop:
  LDA .work2
  CPI 0
  JPZ cls_prep
  LDA .work1
  RSA
  STA .work1
  LDA .work2
  SUI 1
  STA .work2
  JMP crs_loop
cls_prep:
  ; Left shift back by repeat_shift
  LDI .repeat_shift
  STA .work2
cls_loop:
  LDA .work2
  CPI 0
  JPZ chk_cmp
  LDA .work1
  LSA
  STA .work1
  LDA .work2
  SUI 1
  STA .work2
  JMP cls_loop
chk_cmp:
  LDA .work1
  CMP .work3
  JPZ allow_repeat
  JMP after_repeat_gate
allow_repeat:
  LDI 0
  STA .no_input
after_repeat_gate:
  LDA .no_input
  CPI 1
  JPZ after_input_handling
  LDI 1
  STA .no_input
  LDA .bss + 8
  CPI 52
  JPZ handle_left
  CPI 54
  JPZ handle_right
  CPI 47
  JPZ handle_shoot
  CPI 48
  JPZ handle_shoot
  CPI 49
  JPZ handle_shoot
after_input_handling:
  JSR @wait_100
  RET

handle_shoot:
  LDA .bss + 6
  CPI 1
  JPZ after_input_handling    ; return immediately if bullet is already fired
  LDI 1
  STA .bss + 6
  LDA .bss
  STA .bss + 5
  JMP after_input_handling

handle_left:
  LDA .bss
  CPI 0
  JPZ after_input_handling    ; return immediately if position is 0
  SUI 1
  STA .bss
  JMP after_input_handling

handle_right:
  LDA .bss
  CPI .screen_width
  JPZ after_input_handling    ; return immediately if position is screen_width
  ADI 1
  STA .bss
  JMP after_input_handling

check_input:
  KEI
  PHA
  CPI 128
  JPC input_entered     ; handle input if keyboard register is >= 128, since the 128 bit is signal bit
  PLA
  LDI 0
  STA .bss + 7
  RET
input_entered:
  PLA
  SUI 128
  STA .bss + 8
  LDI 1
  STA .bss + 7
  RET

set_no_input:
  LDI 0
  STA .no_input
  ; reset repeat tracking when key released
  LDI 0
  STA .bss + 10
  STA .bss + 11
  JMP after_input_handling

advance_cursor:
  LDI 32
  STA .char
  JSR @write_char
  RET

end:
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR screen_instruction 
  DIS 15            ; set on, display cursor, cursor blink
  JSR screen_instruction
  JSR @newline
  LDI 0
  STA .num_digits
  STA .arg2
  LDI .game_over_text
  STA .arg1
  JSR @echon
  LDA .bss + 9
  STA .arg1
  JSR @display_number
  JSR @newline
  RET

clear_display:
  DIS 1             ; 0000 0001 - clear display
  JSR screen_instruction
  RET

screen_instruction:         ; screen instruction
  DIC 0
  DIC 128                   ; set enable
  DIC 0
  RET

; Local: print null-terminated string at .arg1 (no newline)
print_z:
  LDI 1
  STA .arg2
  LDI 0
  STA .num_digits
  LDA .arg1
  JSR @echon
pz_done:
  RET
