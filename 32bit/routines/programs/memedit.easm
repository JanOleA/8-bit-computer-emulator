;! name: MEMEDIT
;! entry: main
;! deps: display_number, newline, write_char
;! abi: all
;! bss: auto
;! align: 1
;! callable: yes

; Interactive memory editor
; Usage: MEMEDIT <start_addr>
; After prompt '# ', type space-separated decimal values and press Enter to write
; them to memory at the current write pointer. Empty line exits. Write pointer
; advances after each value.

line_len = 40

; BSS locals layout (use .bss offsets directly)
;   .bss      = starting write address (write_base)
;   .bss + 1  = current write address (write_ptr)
;   .bss + 2  = current input buffer pointer (buf_ptr)
;   .bss + 3  = current input length (buf_len)
;   .bss + 4  = base of input buffer, computed at runtime (buf_base)
;   .bss + 5  = tokenizer scan pointer (scan_ptr)
;   .bss + 6  = parsed number accumulator (val_acc)

.invalid_address = "Invalid mem.addr. in memedit: %u"

main:
  ; require at least 1 argument
  LDA .__argv_base
  CPI 1
  JPZ me_go
  RET

me_go:
  ; parse first arg -> write_base
  LDA .__argv_base + 1
  STA .__res2           ; __res2 = pointer to string
  LDI 0
  STA .__res1
me_pn:
  LPA .__res2                ; load mem[mem[.__res2]] into A
  CPI 0
  JPZ me_pn_done
  CPI 32
  JPZ me_pn_done
  SUI 48
  STA .__char
  LDA .__res1
  LSA
  STA .__pow2
  LSA
  LSA
  ADD .__pow2
  STA .__res1
  LDA .__res1
  ADD .__char
  STA .__res1
  LDA .__res2
  ADI 1
  STA .__res2
  JMP me_pn
me_pn_done:
  LDA .__res1
  STA .bss
  STA .bss + 1

  ; init input buffer pointers
  LDI .bss
  ADI 64
  STA .bss + 4
  LDA .bss + 4
  STA .bss + 2
  LDI 0
  STA .bss + 3

  ; initial prompt '# '
  JSR print_prompt
  ; flush any pending key (e.g., the Enter used to launch MEMEDIT)
  JSR flush_input

me_loop:
  JSR check_input
  LDA .__res2
  CPI 0
  JPZ me_loop

  ; Enter?
  LDA .__res1
  CPI 31
  JPZ me_enter
  CPI 32
  JPZ me_enter

  ; Backspace?
  CPI 43
  JPZ me_backspace

  ; Regular character: convert via ascii_map and append to buffer
  LDA .__ascii_start
  ADD .__res1
  LAP
  STA .__char
  JSR @write_char
  ; store into buffer
  LDA .bss + 2
  PHA
  LDA .__char
  SAS
  ; advance ptr and len with clamps
  LDA .bss + 2
  ADI 1
  STA .bss + 2
  ; clamp buf_ptr <= (buf_base + line_len)
  LDA .bss + 4
  ADI .line_len
  STA .__res2
  LDA .bss + 2
  CMP .__res2
  JPZ me_clamp_ptr
  JMP me_after_ptr
me_clamp_ptr:
  LDA .bss + 2
  SUI 1
  STA .bss + 2
me_after_ptr:
  LDA .bss + 3
  ADI 1
  STA .bss + 3
  ; clamp buf_len <= line_len
  LDI .line_len
  CMP .bss + 3
  JPZ me_clamp_len
  JMP me_after_len
me_clamp_len:
  LDA .bss + 3
  SUI 1
  STA .bss + 3
me_after_len:
  ; wait for key release to avoid repeats
  JSR flush_input
  JMP me_loop

; Handle backspace: remove last char from buffer and screen
me_backspace:
  LDA .bss + 3
  CPI 0
  JPZ me_bs_done
  LDA .bss + 2
  SUI 1
  STA .bss + 2
  LDA .bss + 2
  PHA
  LDI 0
  SAS
  LDA .bss + 3
  SUI 1
  STA .bss + 3
  JSR cursor_left
  LDI 32
  JSR @write_char
  JSR cursor_left
me_bs_done:
  ; wait for key release to avoid repeats
  JSR flush_input
  JMP me_loop

; Handle enter: empty line exits; else parse and write values
me_enter:
  ; terminate buffer
  LDA .bss + 2
  PHA
  LDI 0
  SAS
  ; if empty -> exit
  LDA .bss + 3
  CPI 0
  JPZ me_exit
  ; parse and store
  JSR parse_and_store
  ; reset buffer
  LDA .bss + 4
  STA .bss + 2
  LDI 0
  STA .bss + 3
  ; newline and prompt
  JSR @newline
  JSR print_prompt
  ; wait for key release to avoid repeats
  JSR flush_input
  JMP me_loop

pas_invalid_address:
  ; print "Invalid memory address in memedit"
  JSR @newline
  LDI .invalid_address
  PHA
  LDI .bss + 1
  PHA
  JSR @printf
  PLA                   ; pull once from stack so we get to return from memedit
me_exit:
  ; print newline, wait for key release, then clear any debounce flag
  JSR @newline
  JSR flush_input
  LDI 0
  STA .__no_input
  RET

; --- Parsing and writing ---
; parse tokens from buffer and write to memory starting at .write_ptr
parse_and_store:
  LDA .bss + 4
  STA .bss + 5
pas_next_token:
  ; skip spaces
  LPA .bss + 5                ; load mem[mem[.bss + 5]] into A
  CPI 32
  JPZ pas_skip1
  CPI 0
  JPZ pas_done
  JMP pas_start
pas_skip1:
  LDA .bss + 5
  ADI 1
  STA .bss + 5
  JMP pas_next_token
pas_start:
  LDI 0
  STA .bss + 6
  LDI 0
  STA .__num_digits
pas_digits:
  LPA .bss + 5                ; load mem[mem[.bss + 5]] into A
  CPI 48
  JPC pas_check_hi
  JMP pas_after_num
pas_check_hi:
  CPI 58
  JPC pas_after_num
  ; digit: val = val*10 + (ch-48)
  SUI 48
  STA .__char
  LDA .bss + 6
  LSA
  STA .__pow2
  LSA
  LSA
  ADD .__pow2
  STA .bss + 6
  LDA .bss + 6
  ADD .__char
  STA .bss + 6
  ; advance
  LDA .bss + 5
  ADI 1
  STA .bss + 5
  LDA .__num_digits
  ADI 1
  STA .__num_digits
  JMP pas_digits
pas_after_num:
  ; if no digits, treat current char as separator: advance and continue
  LDA .__num_digits
  CPI 0
  JPZ pas_sep_adv
  ; write value to memory at write_ptr
  LDA .bss + 1
  CMP .__sys_reserved_region_end         ; if address >= reserved region end, OK
  JPC pas_address_ok
  JMP pas_invalid_address
pas_address_ok:
  PHA
  LDA .bss + 6
  SAS
  ; advance write_ptr
  LDA .bss + 1
  ADI 1
  STA .bss + 1
  JMP pas_next_token
pas_sep_adv:
  ; advance scan_ptr over non-digit separator and continue
  LDA .bss + 5
  ADI 1
  STA .bss + 5
  JMP pas_next_token
pas_done:
  RET

; --- UI helpers (adapted from SHELL) ---
print_prompt:
  LDI 35              ; '#'
  JSR @write_char
  LDI 32
  JSR @write_char
  ; print current write pointer in brackets: "[<addr>] "
  LDI 91              ; '['
  JSR @write_char
  LDA .bss + 1        ; current write address
  JSR @display_number
  LDI 93              ; ']'
  JSR @write_char
  LDI 32              ; space
  JSR @write_char
  RET

cursor_left:
  DIS 18
  JSR @toggle_display_enable
  RET

check_input:
  KEI
  PHA
  CPI 128
  JPC input_entered     ; handle input if keyboard register is >= 128, since the 128 bit is signal bit
  PLA
  LDI 0
  STA .__res2
  RET
input_entered:
  PLA
  SUI 128
  OUT
  STA .__res1
  LDI 1
  STA .__res2
  RET

; Drain any pending keypresses so we start with a clean state
flush_input:
  JSR check_input
  LDA .__res2
  CPI 0
  JPZ fi_done
  JMP flush_input
fi_done:
  RET
