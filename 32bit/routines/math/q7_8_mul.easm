;! name: Q78MUL
;! entry: q7_8_mul
;! deps: multiply
;! abi: sysinfo
;! bss: auto
;! align: 1

; Multiply two Q7.8 fixed-point signed values (two's complement) and return Q7.8.
; Call signature: q7_8_mul(SP - 3, SP - 2) = q7_8_mul(a, b)
; Inputs:
;   Stack Pointer - 3 = a (Q7.8, sign-extended to word)
;   Stack Pointer - 2 = b (Q7.8, sign-extended to word)
; Returns: A = result (Q7.8), rounded to nearest (away from zero on ties)

; Notes on compare/branch convention used here (to avoid inverted conditions):
; - "CPI k" / "CMP X" sets flags as A - k/X.
; - "JPC label" is taken when A >= k/X (no borrow), used for tests like ">= threshold".
; - "JPZ label" is taken when A == k/X (zero result), used for equality/overflow wrap checks.

; BSS locals
a_val   = .bss + 0
b_val   = .bss + 1
sign    = .bss + 2      ; 0=positive, 1=negative
mag_a   = .bss + 3
mag_b   = .bss + 4
prod    = .bss + 5      ; result magnitude (Q7.8)
mask    = .bss + 6      ; sign bit mask (1<<(bits-1))
cnt     = .bss + 7
ip_a    = .bss + 8      ; |a| >> 8
ip_b    = .bss + 9      ; |b| >> 8
fr_a    = .bss + 10     ; |a| & 0xFF
fr_b    = .bss + 11     ; |b| & 0xFF
t1      = .bss + 12     ; (ip_a * ip_b) << 8
t2      = .bss + 13     ; ip_a * fr_b
t3      = .bss + 14     ; ip_b * fr_a
t4      = .bss + 15     ; (fr_a * fr_b + 128) >> 8

q7_8_mul:
  ; prologue and fetch args (following multiply.easm convention)
  PLA
  MOVAB
  PLA
  STA .b_val
  PLA
  STA .a_val
  MOVBA
  PHA

  ; compute sign bit mask = 1 << (bits_avail - 1)
  LDI 1
  STA .mask
  LDA .__sys_bits_avail
  SUI 1
  STA .cnt
qm_mask_loop:
  LDA .cnt
  CPI 0
  JPZ qm_mask_done
  LDA .mask
  LSA
  STA .mask
  LDA .cnt
  SUI 1
  STA .cnt
  JMP qm_mask_loop
qm_mask_done:
  ; sign = (a<0) XOR (b<0)
  ; test a < 0
  LDA .a_val
  CMP .mask
  JPC qm_a_neg
  LDI 0
  STA .sign
  JMP qm_test_b
qm_a_neg:
  LDI 1
  STA .sign
qm_test_b:
  LDA .b_val
  CMP .mask
  JPC qm_b_neg
  ; b non-negative
  JMP qm_abs
qm_b_neg:
  ; flip sign (XOR 1)
  LDA .sign
  CPI 0
  JPZ qm_set1
  LDI 0
  STA .sign
  JMP qm_abs
qm_set1:
  LDI 1
  STA .sign

qm_abs:
  ; mag_a = abs(a_val)
  LDA .a_val
  CMP .mask
  JPC qm_abs_a_neg
  STA .mag_a
  JMP qm_abs_b
qm_abs_a_neg:
  LDI 0
  SUB .a_val
  STA .mag_a
qm_abs_b:
  LDA .b_val
  CMP .mask
  JPC qm_abs_b_neg
  STA .mag_b
  JMP qm_mul
qm_abs_b_neg:
  LDI 0
  SUB .b_val
  STA .mag_b

qm_mul:
  ; Decomposed Q7.8 multiply to avoid wide intermediate:
  ; result = (ip_a*ip_b)<<8 + (ip_a*fr_b + ip_b*fr_a) + ((fr_a*fr_b + 128)>>8)

  ; ip_a = mag_a >> 8
  LDA .mag_a
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .ip_a
  ; fr_a = mag_a - (ip_a<<8)
  LDA .ip_a
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  STA .prod     ; use prod as tmp for ip_a<<8
  LDA .mag_a
  SUB .prod
  STA .fr_a

  ; ip_b = mag_b >> 8
  LDA .mag_b
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .ip_b
  ; fr_b = mag_b - (ip_b<<8)
  LDA .ip_b
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  STA .prod     ; reuse as tmp for ip_b<<8
  LDA .mag_b
  SUB .prod
  STA .fr_b

  ; t1 = (ip_a * ip_b) << 8
  LDA .ip_b
  PHA
  LDA .ip_a
  PHA
  JSR @multiply
  STA .t1
  LDA .t1
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  LSA
  STA .t1

  ; t2 = ip_a * fr_b
  LDA .fr_b
  PHA
  LDA .ip_a
  PHA
  JSR @multiply
  STA .t2

  ; t3 = ip_b * fr_a
  LDA .fr_a
  PHA
  LDA .ip_b
  PHA
  JSR @multiply
  STA .t3

  ; t4 = (fr_a * fr_b + 128) >> 8
  LDA .fr_b
  PHA
  LDA .fr_a
  PHA
  JSR @multiply
  ADI 128
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  STA .t4

  ; prod = t1 + t2 + t3 + t4 (mod word)
  LDA .t1
  ADD .t2
  ADD .t3
  ADD .t4
  STA .prod

  ; apply sign
  LDA .sign
  CPI 0
  JPZ qm_ret_pos
  ; negative -> negate
  LDI 0
  SUB .prod
  RET
qm_ret_pos:
  LDA .prod
  RET
