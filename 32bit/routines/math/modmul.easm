;! name: MODMUL
;! entry: modmul
;! deps: divide
;! abi: all
;! bss: auto
;! align: 1

; Compute (__arg1 * __arg2) mod mod, where mod is in .__res1.
; Returns A = result.
; Locals:
;   .bss     = res
;   .bss + 1 = x
;   .bss + 2 = y
;   .bss + 3 = mod

modmul:
  ; Load inputs
  LDA .__arg1
  STA .bss + 1      ; x
  LDA .__arg2
  STA .bss + 2      ; y
  LDA .__res1
  STA .bss + 3      ; mod
  LDI 0
  STA .bss          ; res = 0

  ; Reduce x modulo mod to ensure doubling step needs at most one subtraction
  ; x = x % mod
  LDA .bss + 1
  STA .__arg1
  LDA .bss + 3
  STA .__arg2
  JSR @divide
  LDA .__res2
  STA .bss + 1

mm_loop:
  ; if y == 0 -> done
  LDA .bss + 2
  CPI 0
  JPZ mm_done
  ; Shift y and branch on prior LSB via carry
  RSA
  STA .char         ; store y >> 1 for later
  JPC mm_add

mm_store_y:
  LDA .char
  STA .bss + 2

  ; x = (x + x) mod mod
  LDA .bss + 1
  ADD .bss + 1
  STA .bss + 1
  ; if add overflowed (carry) OR x >= mod, subtract mod
  JPC mm_x_sub_carry
  CMP .bss + 3
  JPC mm_x_sub_carry
  JMP mm_x_done
mm_add:
  ; odd -> res = (res + x) mod mod
  LDA .bss
  ADD .bss + 1
  STA .bss
  ; if add overflowed (carry) OR res >= mod, subtract mod
  JPC mm_sub_mod_carry
  CMP .bss + 3
  JPC mm_sub_mod_carry
  JMP mm_store_y
mm_sub_mod_carry:
  LDA .bss
  SUB .bss + 3
  STA .bss
  JMP mm_store_y
mm_x_sub_carry:
  LDA .bss + 1
  SUB .bss + 3
  STA .bss + 1
mm_x_done:
  JMP mm_loop

mm_done:
  LDA .bss
  RET
