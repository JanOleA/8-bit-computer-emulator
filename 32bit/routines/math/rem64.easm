;! name: REM64
;! entry: rem64
;! deps: divide, modmul, __pow2_32_mod
;! abi: all
;! bss: auto
;! align: 1

; Compute (hi * 2^32 + lo) mod mod, where
;   .__arg1 = lo
;   .__arg2 = hi
;   .__res1 = mod
; Returns A = remainder
; Locals:
;   .bss     = mod
;   .bss + 1 = lo_mod
;   .bss + 2 = hi_mod
;   .bss + 3 = pow (2^32 % mod)
;   .bss + 4 = hi_term

rem64:
  ; save mod
  LDA .__res1
  STA .bss
  ; preserve original inputs (lo, hi) because .__arg1/.__arg2 are clobbered by subcalls
  LDA .__arg1
  STA .bss + 5      ; save lo
  LDA .__arg2
  STA .bss + 6      ; save hi
  ; lo_mod = lo % mod
  LDA .bss + 5
  STA .__arg1
  LDA .bss
  STA .__arg2
  JSR @divide
  LDA .__res2
  STA .bss + 1
  ; hi_mod = hi % mod
  LDA .bss + 6
  STA .__arg1
  LDA .bss
  STA .__arg2
  JSR @divide
  LDA .__res2
  STA .bss + 2
  ; pow = 2^32 % mod
  LDA .bss
  PHA
  JSR @__pow2_32_mod
  STA .bss + 3
  ; hi_term = (hi_mod * pow) % mod
  LDA .bss + 2
  STA .__arg1
  LDA .bss + 3
  STA .__arg2
  LDA .bss
  STA .__res1
  JSR @modmul
  STA .bss + 4
  ; r = (hi_term + lo_mod) % mod
  ADD .bss + 1
  ; if r >= mod, subtract
  CMP .bss
  JPC r_sub
  RET
r_sub:
  SUB .bss
  RET
