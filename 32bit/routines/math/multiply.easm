;! name: MULTIPLY
;! entry: multiply
;! deps:
;! abi: os
;! bss: auto
;! align: 4

; --- Multiply .arg1 and .arg2, store the result in .res1 and the A register

; Inputs: .arg1, .arg2
; Output: .res1 and A
; Temps:  .bss, .bss + 1, .bss + 2

multiply:
  ; res = 0
  LDI 0
  STA .res1

  ; m1 = arg1, m2 = arg2
  LDA .arg1
  STA .bss
  LDA .arg2
  STA .bss + 1

mult_loop:
  ; if m2 == 0 -> done  (need to set ZF!)
  LDA .bss + 1
  CPI 0
  JPZ mult_done

  ; compute new m2 and branch on prior LSB via carry
  RSA                     ; A = m2 >> 1, carry = original LSB
  STA .bss + 2            ; keep shifted value for later store
  JPC mult_add

mult_shift:
  LDA .bss + 2
  STA .bss + 1

  ; m1 <<= 1
  LDA .bss
  LSA
  STA .bss

  JMP mult_loop

mult_add:
  ; odd -> res += m1
  LDA .res1
  ADD .bss
  STA .res1
  JMP mult_shift

mult_done:
  LDA .res1
  RET
