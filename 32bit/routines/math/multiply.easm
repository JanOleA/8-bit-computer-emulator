;! name: MULTIPLY
;! entry: multiply
;! deps:
;! abi: os
;! bss: auto
;! align: 4

; --- Multiply two inputs (retrieve first two from stack) store the result in the A register

; Output: .res1 and A
; Temps:  .bss + 1, .bss + 2, .bss + 3, bss + 4

multiply:
  PLA                     ; get return address from stack
  MOVAB                   ; move return address to B for now

  PLA                     ; arg1
  ; m1 = bss + 1, m2 = bss + 2
  STA .bss + 1
  PLA                     ; arg2
  STA .bss + 2
  
  MOVBA                   ; move return address back to A
  PHA                     ; push it back to stack

  ; res = 0
  LDI 0
  STA .bss + 4


mult_loop:
  ; if m2 == 0 -> done  (need to set ZF!)
  LDA .bss + 2
  CPI 0
  JPZ mult_done

  ; compute new m2 and branch on prior LSB via carry
  RSA                     ; A = m2 >> 1, carry = original LSB
  STA .bss + 3            ; keep shifted value for later store
  JPC mult_add

mult_shift:
  LDA .bss + 3
  STA .bss + 2

  ; m1 <<= 1
  LDA .bss + 1
  LSA
  STA .bss + 1

  JMP mult_loop

mult_add:
  ; odd -> res += m1
  LDA .bss + 4
  ADD .bss + 1
  STA .bss + 4
  JMP mult_shift

mult_done:
  LDA .bss + 4
  RET
