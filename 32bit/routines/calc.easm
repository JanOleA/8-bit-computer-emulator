;! name: CALC
;! entry: calc
;! deps: display_number, divide, mult
;! abi: os
;! bss: none
;! align: 100

; CALC <num1> <op> <num2>
; Computes num1 <op> num2 where op is one of + - * /
; Prints the result in decimal using display_number

calc:
  ; require at least 3 args
  LDI .argv_base
  PHA
  LAS
  CPI 3
  JPZ cl_go
  RET

cl_go:
  ; parse first number -> work1
  LDI .argv_base
  ADI 1
  PHA
  LAS
  STA .arg1           ; arg1 = pointer to first number string
  JSR parse_number
  LDA .res1
  STA .work1

  ; read operator char -> .char
  LDI .argv_base
  ADI 2
  PHA
  LAS
  STA .work2          ; pointer to operator token
  LDA .work2
  PHA
  LAS
  STA .char

  ; parse second number -> work2
  LDI .argv_base
  ADI 3
  PHA
  LAS
  STA .arg1           ; arg1 = pointer to second number string
  JSR parse_number
  LDA .res1
  STA .work2

  ; dispatch by operator
  LDA .char
  CPI 43              ; '+'
  JPZ do_add
  CPI 45              ; '-'
  JPZ do_sub
  CPI 42              ; '*'
  JPZ do_mul
  CPI 47              ; '/'
  JPZ do_div
  ; unknown op -> return
  RET

do_add:
  LDA .work1
  ADD .work2
  JMP do_print

do_sub:
  LDA .work1
  SUB .work2
  JMP do_print

do_mul:
  LDA .work1
  STA .arg1
  LDA .work2
  STA .arg2
  JSR @multiply
  JMP do_print

do_div:
  LDA .work1
  STA .arg1
  LDA .work2
  STA .arg2
  JSR @divide
  ; A holds quotient, .res2 holds remainder â€” print both
  ; Save quotient and remainder before display_number overwrites .res2
  STA .work4          ; save quotient
  LDA .res2
  STA .work3          ; save remainder
  LDA .work4          ; restore quotient
  ; print quotient
  STA .arg1
  JSR @display_number
  ; print " R "
  LDI 32
  STA .char
  JSR write_char
  LDI 82              ; 'R'
  STA .char
  JSR write_char
  LDI 32
  STA .char
  JSR write_char
  ; print remainder
  LDA .work3
  STA .arg1
  JSR @display_number
  JSR newline
  RET

do_print:
  STA .arg1
  JSR @display_number
  JSR newline
  RET

; Parse a decimal number at .arg1 into .res1 (stops at first non-digit)
parse_number:
  LDI 0
  STA .res1
pn_loop:
  LDA .arg1
  PHA
  LAS                 ; A = current char
  CPI 48              ; if A < '0' -> done
  JPC pn_ge_48
  JMP pn_done
pn_ge_48:
  CPI 58              ; if A >= ':' -> done
  JPC pn_done
  ; convert to digit and accumulate: res1 = res1*10 + digit
  SUI 48
  STA .textloc        ; temp digit
  LDA .res1
  LSA
  STA .pow2           ; tmp = res*2
  LSA
  LSA                 ; A = res*8
  ADD .pow2           ; A = res*10
  ADD .textloc
  STA .res1
  ; advance pointer
  LDA .arg1
  ADI 1
  STA .arg1
  JMP pn_loop
pn_done:
  RET

; simple newline helper
newline:
  DIS 32
  DIC 0
  DIC 128
  DIC 0
  RET

; local write_char helper
write_char:
  LDD .char
  DIC 0
  DIC 64
  DIC 192
  DIC 0
  RET
