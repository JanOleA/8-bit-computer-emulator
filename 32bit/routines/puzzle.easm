;! name: PUZZLE
;! entry: main
;! deps: multiply, divide, display_number
;! abi: os
;! bss: auto
;! align: 20

bss        = 120020 ; check_value
bss + 1    = 120021 ; loop_index
bss + 2    = 120022 ; half_check
bss + 3    = 120023 ; square_val
bss + 4    = 120024 ; square_result
bss + 5    = 120025 ; square_sum
bss + 6    = 120026 ; num_primes
bss + 7    = 120027 ; finds

main:
  LDI 4
  STA .bss + 5
  LDI 3
  STA .bss    
  LDI 1
  STA .bss + 6
  LDI 232
  STA .bss + 7
main_loop:
  JSR check_prime_os
  CPI 0
  JPZ next_val
its_prime:
  LDA .bss + 6
  ADI 1
  STA .bss + 6
  LDA .bss    
  STA .bss + 3
  JSR square_os
  LDA .bss + 5
  ADD .bss + 4
  STA .bss + 5
  ; (sum of squares) % (#primes) == 0 ?
  LDA .bss + 5
  STA .arg1
  LDA .bss + 6
  STA .arg2
  JSR @divide
  LDA .res2
  CPI 0
  JPZ found_one
  JMP next_val
found_one:
  ; print bss + 6
  LDA .bss + 6
  STA .arg1
  JSR @display_number
  DIS 32
  DIC 0
  DIC 128
  DIC 0
  ; store bss + 6 at bss + 7++
  LDA .bss + 7
  ADI 1
  STA .bss + 7
  LDA .bss + 7
  SUI 1
  PHA
  LDA .bss + 6
  SAS
next_val:
  LDA .bss
  ADI 2
  CPI 500
  JPC done
  STA .bss    
  JMP main_loop

; square via OS multiply
square_os:
  LDA .bss + 3
  STA .arg1
  LDA .bss + 3
  STA .arg2
  JSR @multiply
  STA .bss + 4
  RET

; primality test using OS divide; returns A=1 if prime else A=0
check_prime_os:
  LDA .bss    
  RSA
  STA .bss + 2
  LDI 3
  STA .bss + 1
prime_loop_os:
  LDA .bss + 1
  CMP .bss + 2
  JPC prime_os
  LDA .bss    
  STA .arg1
  LDA .bss + 1
  STA .arg2
  JSR @divide
  LDA .res2
  CPI 0
  JPZ not_prime_os
  LDA .bss + 1
  ADI 2
  STA .bss + 1
  JMP prime_loop_os
not_prime_os:
  LDI 0
  RET
prime_os:
  LDI 1
  RET
done:
  RET
