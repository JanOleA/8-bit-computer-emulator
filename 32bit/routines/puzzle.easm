;! name: PUZZLE
;! entry: main
;! deps: multiply, divide, display_number
;! abi: os
;! bss: none
;! align: 100

check_value   = 120020
loop_index    = 120021
half_check    = 120022
square_val    = 120023
square_result = 120024
square_sum    = 120025
num_primes    = 120026
finds         = 120027

main:
  LDI 4
  STA .square_sum
  LDI 3
  STA .check_value
  LDI 1
  STA .num_primes
  LDI 232
  STA .finds
main_loop:
  JSR check_prime_os
  CPI 0
  JPZ next_val
its_prime:
  LDA .num_primes
  ADI 1
  STA .num_primes
  LDA .check_value
  STA .square_val
  JSR square_os
  LDA .square_sum
  ADD .square_result
  STA .square_sum
  ; (sum of squares) % (#primes) == 0 ?
  LDA .square_sum
  STA .arg1
  LDA .num_primes
  STA .arg2
  JSR @divide
  LDA .res2
  CPI 0
  JPZ found_one
  JMP next_val
found_one:
  ; print num_primes
  LDA .num_primes
  STA .arg1
  JSR @display_number
  DIS 32
  DIC 0
  DIC 128
  DIC 0
  ; store num_primes at finds++
  LDA .finds
  ADI 1
  STA .finds
  LDA .finds
  SUI 1
  PHA
  LDA .num_primes
  SAS
next_val:
  LDA .check_value
  ADI 2
  JPC main
  STA .check_value
  JMP main_loop

; square via OS multiply
square_os:
  LDA .square_val
  STA .arg1
  LDA .square_val
  STA .arg2
  JSR @multiply
  STA .square_result
  RET

; primality test using OS divide; returns A=1 if prime else A=0
check_prime_os:
  LDA .check_value
  RSA
  STA .half_check
  LDI 3
  STA .loop_index
prime_loop_os:
  LDA .loop_index
  CMP .half_check
  JPC prime_os
  LDA .check_value
  STA .arg1
  LDA .loop_index
  STA .arg2
  JSR @divide
  LDA .res2
  CPI 0
  JPZ not_prime_os
  LDA .loop_index
  ADI 2
  STA .loop_index
  JMP prime_loop_os
not_prime_os:
  LDI 0
  RET
prime_os:
  LDI 1
  RET
