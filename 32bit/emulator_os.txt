
; keep abi_vars in sync with compile_routines.py and get_os_abi_var.easm

__char = 2000                 ; variable for printing
__textloc = 2001              ; location of next textline to print
__arg1 = 2002                 ; argument 1 for subroutines
__arg2 = 2003                 ; argument 2 for subroutines
__res1 = 2004                 ; result 1 for subroutines
__res2 = 2005                 ; result 2 for subroutines
__res3 = 2014                 ; result 3 for subroutines
__pow2 = 2006                 ; special variable for divide routine
__num_digits = 2007           ; number of digits to print in the display_number routine
__ascii_start = 2008          ; location where ascii map starts
__no_input = 2009             ; whether or not input has been reset
; Work registers for tokenizer
__work1 = 2010
__work2 = 2011
__work3 = 2012
__work4 = 2013                ; preserved entry base for handler lookup

__random_seed = 2600
__inc_random_seed = 2601
__sys_bits_avail = 2602           ; on startup, boot process will calculate the number of bits available in the A register
bits_checker = 2599

__sys_screen_width = 2603        ; screen width in characters
__sys_screen_height = 2604       ; screen height in characters

2603 = 40
2604 = 20

text = 2020     ; 16 bytes
text2 = 2036    ; 16 bytes
text_su = 2052  ; 12 bytes
space = 2064    ; 2 bytes
ascii_map = 2066 ; 56 bytes

__input_buf   = 2122            ; start of input buffer (80 bytes reserved)
__input_ptr   = 2202
__cmd_len     = 2203
__cmd_ready   = 2204

.text     = "     EmuOS     "
.text2    = "    Welcome!   "
.text_su  = "Starting..."
.space    = " "
.ascii_map = "0123456789 QWERTYUIOP ASDFGHJKL  ZXCVBNM,.             "
.__ascii_start = 2066
; Map arithmetic keys to ASCII for the 32-bit keyboard:
; Key codes: 10:'/', 21:'*', 50:'+', 51:'-'
.ascii_map + 10 = "/"
.ascii_map + 21 = "*"
.ascii_map + 50 = "+"
.ascii_map + 51 = "-"

; ----- Call stub for returning external commands -----
; A small trampoline at a fixed address: [CALL_STUB]=JSR, [CALL_STUB+1]=handler addr (patched), [CALL_STUB+2]=RET
CALL_STUB = 19996
19996 = 16
19997 = 11410
19998 = 17
19999 = 11410

call_stub_initial = 19999   ; the initial address for the call stub is stored here on boot in order to reset it after a program call

; ----- argv/argv buffer reservation -----
__argv_base = 2400            ; argv block base (argc + argv pointers)
__argv_buf  = 2500            ; buffer where argument strings are copied

; Program dispatch table (name[0..7], addr[8], reserved[9]) repeated; sentinel when name[0]==0
__sys_prog_table = 3000

start:
  LDI 42
  STA .__random_seed
  LDI 1
  STA .__inc_random_seed
check_bits:
  LDI 1
  STA .bits_checker
  STA .__sys_bits_avail
cb_loop:
  LDA .bits_checker
  LSA
  JPC initialize
  STA .bits_checker
  LDA .__sys_bits_avail
  ADI 1
  STA .__sys_bits_avail
  JMP cb_loop
initialize:
  JSR initialize_display
  LDI 2052
  STA .__textloc
  LDI 12
  STA .__num_digits
  JSR print
  LDI 0                   ; set variables to zero
  STA .__char
  STA .__arg1
  STA .__arg2
  STA .__res1
  STA .__res2
  STA .__pow2
  STA .__num_digits
  LDI 2020
  STA .__textloc
  LDI 16
  STA .__num_digits
  JSR print
  LDI 2036
  STA .__textloc
  LDI 16
  STA .__num_digits
  JSR print
  JSR #19996

initialize_display: ; initializes the display
  DIS 1             ; 0000 0001 - clear display
  JSR instruction
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR instruction 
  DIS 15            ; set on, display cursor, cursor blink
  JSR instruction
  RET

print:              ; 
  LDA .__textloc
  STA .__arg1
  JSR #11238        ; must be switched to ECHON location if it changes
  RET

newline:            ; print newline on the screen
  DIS 32            ; data for newline
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

instruction:        ; screen instruction
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET


; --------------
; Command parsing (removed; handled by shell)
; --------------
