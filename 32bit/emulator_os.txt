char = 2000                 ; variable for printing
textloc = 2001              ; location of next textline to print
arg1 = 2002                 ; argument 1 for subroutines
arg2 = 2003                 ; argument 2 for subroutines
res1 = 2004                 ; result 1 for subroutines
res2 = 2005                 ; result 2 for subroutines
pow2 = 2006                 ; special variable for divide routine
num_digits = 2007           ; number of digits to print in the display_number routine
ascii_start = 2008          ; location where ascii map starts
no_input = 2009             ; whether or not input has been reset
; Work registers for tokenizer
work1 = 2010
work2 = 2011
work3 = 2012
work4 = 2013                ; preserved entry base for handler lookup

random_seed = 2600
inc_random_seed = 2601
bits_avail = 2602           ; on startup, boot process will calculate the number of bits available in the A register
bits_checker = 2599

text = 2020     ; 16 bytes
text2 = 2036    ; 16 bytes
text_su = 2052  ; 12 bytes
space = 2064    ; 2 bytes
ascii_map = 2066 ; 56 bytes

input_buf   = 2122            ; start of input buffer (80 bytes reserved)
input_ptr   = 2202
cmd_len     = 2203
cmd_ready   = 2204

.text     = "     EmuOS     "
.text2    = "    Welcome!   "
.text_su  = "Starting..."
.space    = " "
.ascii_map = "0123456789 QWERTYUIOP ASDFGHJKL  ZXCVBNM,.             "
.ascii_start = 2066
; Map arithmetic keys to ASCII for the 32-bit keyboard:
; Key codes: 10:'/', 21:'*', 50:'+', 51:'-'
.ascii_map + 10 = "/"
.ascii_map + 21 = "*"
.ascii_map + 50 = "+"
.ascii_map + 51 = "-"

; ----- Call stub for returning external commands -----
; A small trampoline at a fixed address: [CALL_STUB]=JSR, [CALL_STUB+1]=handler addr (patched), [CALL_STUB+2]=RET
CALL_STUB = 19996
19996 = 16
19997 = 6988
19998 = 17

call_stub_initial = 19999   ; the initial address for the call stub is stored here on boot in order to reset it after a program call

; ----- argv/argv buffer reservation -----
argv_base = 2400            ; argv block base (argc + argv pointers)
argv_buf  = 2500            ; buffer where argument strings are copied

; Program dispatch table (name[0..7], addr[8], reserved[9]) repeated; sentinel when name[0]==0
prog_table = 3000

start:
  LDI 42
  STA .random_seed
  LDI 1
  STA .inc_random_seed
check_bits:
  LDI 1
  STA .bits_checker
  STA .bits_avail
cb_loop:
  LDA .bits_checker
  LSA
  JPC call_stub_setup
  STA .bits_checker
  LDA .bits_avail
  ADI 1
  STA .bits_avail
  JMP cb_loop
call_stub_setup:          ; store call stub initial entry in 19999
  LDA 19997
  STA .call_stub_initial
  JSR initialize_display
  LDI 2052
  STA .textloc
  LDI 12
  STA .num_digits
  JSR print
  LDI 0                   ; set variables to zero
  STA .char
  STA .arg1
  STA .arg2
  STA .res1
  STA .res2
  STA .pow2
  STA .num_digits
  LDI 2020
  STA .textloc
  LDI 16
  STA .num_digits
  JSR print
  LDI 2036
  STA .textloc
  LDI 16
  STA .num_digits
  JSR print
  JSR newline
  JSR #19996

initialize_display: ; initializes the display
  DIS 1             ; 0000 0001 - clear display
  JSR instruction
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR instruction 
  DIS 15            ; set on, display cursor, cursor blink
  JSR instruction
  RET

print:              ; 
  LDA .textloc
  STA .arg1
  JSR #6756        ; must be switched to ECHON location if it changes
  RET

newline:            ; print newline on the screen
  DIS 32            ; data for newline
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

instruction:        ; screen instruction
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET


; --------------
; Command parsing (removed; handled by shell)
; --------------
