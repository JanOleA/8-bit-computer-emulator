char = 4000                 ; variable for printing
textloc = 4001              ; location of next textline to print
arg1 = 4002                 ; argument 1 for subroutines
arg2 = 4003                 ; argument 2 for subroutines
res1 = 4004                 ; result 1 for subroutines
res2 = 4005                 ; result 2 for subroutines
pow2 = 4006                 ; special variable for divide routine
num_digits = 4007           ; number of digits to print in the display_number routine
ascii_start = 4008          ; location where ascii map starts
no_input = 4009             ; whether or not input has been reset

text = 4020     ; 16 bytes
text2 = 4036    ; 16 bytes
text_su = 4052  ; 12 bytes
space = 4064    ; 2 bytes
ascii_map = 4066 ; 56 bytes

input_buf = 4122            ; start of input buffer (80 bytes reserved)

.text     = "  EmuOS alpha  "
.text2    = "    Welcome!   "
.text_su  = "Starting..."
.space    = " "
.ascii_map = "0123456789 QWERTYUIOP ASDFGHJKL  ZXCVBNM,.             "
.ascii_start = 4066
; Map arithmetic keys to ASCII for the 32-bit keyboard:
; Key codes: 10:'/', 21:'*', 50:'+', 51:'-'
.ascii_map + 10 = "/"
.ascii_map + 21 = "*"
.ascii_map + 50 = "+"
.ascii_map + 51 = "-"

; ----- Call stub for returning external commands -----
; A small trampoline at a fixed address: [CALL_STUB]=JSR, [CALL_STUB+1]=handler addr (patched), [CALL_STUB+2]=RET
CALL_STUB = 19800
19800 = 16
19801 = 21200
19802 = 17

; ----- argv/argv buffer reservation -----
argv_base = 4400            ; argv block base (argc + argv pointers)
argv_buf  = 4500            ; buffer where argument strings are copied
; Work registers for tokenizer
work1 = 4010
work2 = 4011
work3 = 4012
work4 = 4013         ; preserved entry base for handler lookup

; Program dispatch table (name[0..7], addr[8], reserved[9]) repeated; sentinel when name[0]==0
prog_table = 10000
; Command/program table entries: name[0..7], addr[8], reserved[9]
.prog_table + 0  = "MULTIPLY"
.prog_table + 8 = 20000
.prog_table + 9 = 0
.prog_table + 10  = "DIVIDE"
.prog_table + 18 = 20100
.prog_table + 19 = 0
.prog_table + 20  = "DISPNUM"
.prog_table + 28 = 20200
.prog_table + 29 = 0
.prog_table + 30  = "LIST"
.prog_table + 38 = 20300
.prog_table + 39 = 0
.prog_table + 40  = "PEEK"
.prog_table + 48 = 20500
.prog_table + 49 = 0
.prog_table + 50  = "POKE"
.prog_table + 58 = 20600
.prog_table + 59 = 0
.prog_table + 60  = "PRIMES"
.prog_table + 68 = 20800
.prog_table + 69 = 0
.prog_table + 70  = "PUZZLE"
.prog_table + 78 = 20900
.prog_table + 79 = 0
.prog_table + 80  = "SHELL"
.prog_table + 88 = 21200
.prog_table + 89 = 0
.prog_table + 90 = 0    ; sentinel

start:
  JSR initialize_display
  LDI 4052
  STA .textloc
  JSR print
  JSR ret_home
  LDI 0           ; set variables to zero
  STA .char
  STA .arg1
  STA .arg2
  STA .res1
  STA .res2
  STA .pow2
  STA .num_digits
  LDI 4020
  STA .textloc
  JSR print
  JSR newline
  LDI 4036
  STA .textloc
  JSR print
  JSR newline
  JSR newline
  JSR #19800

initialize_display: ; initializes the display
  DIS 1             ; 0000 0001 - clear display
  JSR instruction
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR instruction 
  DIS 15            ; set on, display cursor, cursor blink
  JSR instruction
  RET

print:              ; gets the first memory address for a string from .textloc and prints it to console (null terminated)
  JSR get_next_char
  CPI 0
  JPZ end_print
  JSR write_char
  JMP print
end_print:
  RET

get_next_char:      ; gets the next character from .textloc and increases .textloc by 1
  LDA .textloc
  PHA
  ADI 1
  STA .textloc
  LAS               ; get the value from .textloc into A
  STA .char
  RET

write_char:         ; write the character in .char to screen
  LDD .char
  DIC 0
  DIC 64            ; set read
  DIC 192           ; set read + enable
  DIC 0
  RET

newline:            ; print newline on the screen
  DIS 32            ; data for newline
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

ret_home:           ; return to home (first column) on current line on screen
  JSR newline
  DIS 24            ; data for cursor up
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

instruction:        ; screen instruction
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET


; --------------
; Command parsing
; --------------

run_command:
  ; Set pointer to start of input buffer
  LDI .input_buf
  STA .arg1
  JSR skip_spaces

  ; First try dispatch table
  JSR dispatch_program
  ; If .res1 == 1, program was launched
  LDA .res1
  CPI 1
  JPZ rc_done

rc_run_fallback:
  ; Fallback: RUN <addr>
  ; Check token "RUN"
  LDA .arg1
  PHA
  LAS
  CPI 82            ; 'R'
  JPZ rc_ch1
  RET               ; unknown command → ignore
rc_ch1:
  LDA .arg1
  ADI 1
  PHA
  LAS
  CPI 85            ; 'U'
  JPZ rc_ch2
  RET
rc_ch2:
  LDA .arg1
  ADI 2
  PHA
  LAS
  CPI 78            ; 'N'
  JPZ rc_delim
  RET
rc_delim:
  LDA .arg1
  ADI 3
  STA .arg1
  ; parse decimal address
  JSR parse_number
  ; push target address and RET to jump
  LDA .res1
  PHA
  RET

rc_done:
  RET

; Skip spaces at .arg1
skip_spaces:
  LDA .arg1
  PHA
  LAS
  CPI 32
  JPZ sksp_inc
  RET
sksp_inc:
  LDA .arg1
  ADI 1
  STA .arg1
  JMP skip_spaces

; Parse a decimal number at .arg1 into .res1 and advance .arg1
parse_number:
  LDI 0
  STA .res1
  JSR skip_spaces
pn_loop:
  LDA .arg1
  PHA
  LAS                 ; A = current char
  CPI 48              ; if A < '0' -> done
  JPC pn_check_hi
  JMP pn_done
pn_check_hi:
  CPI 58              ; if A >= ':' -> done
  JPC pn_done
  ; convert to digit
  SUI 48
  STA .char
  ; res1 = res1*10
  LDA .res1
  LSA
  STA .pow2           ; reuse as tmp = res*2
  LSA
  LSA                 ; A = res*8
  ADD .pow2           ; A = res*10
  STA .res1
  ; res1 += digit
  LDA .res1
  ADD .char
  STA .res1
  ; advance pointer
  LDA .arg1
  ADI 1
  STA .arg1
  JMP pn_loop
pn_done:
  RET

; Dispatches a program by token using the table at .prog_table
; On success: launches program (RET into its address); On no match: sets .res1=0 and returns
dispatch_program:
  LDI 0
  STA .res1
  ; token start in .arg1
  LDA .arg1
  STA .textloc         ; reuse as token pointer (tp)
  ; table pointer in .arg2
  LDI .prog_table
  STA .arg2

dp_entry:
  ; Check sentinel: if name[0] == 0 → no match
  LDA .arg2
  PHA
  LAS
  CPI 0
  JPZ dp_nomatch
  ; Compare up to 8 chars
  LDA .arg2
  STA .res2            ; res2 = name ptr
  LDA .textloc
  STA .pow2            ; pow2 = tp (input)
  LDI 8
  STA .num_digits      ; use as counter
dp_cmp_loop:
  ; load input char
  LDA .pow2
  PHA
  LAS
  STA .char
  ; load name char
  LDA .res2
  PHA
  LAS
  STA .no_input        ; use as temp
  ; If name char == 0 and input is 0 or space → match
  LDA .no_input
  CPI 0
  JPZ dp_ct_zero
  ; If input is 0/space and name not zero → mismatch
  LDA .char
  CPI 0
  JPZ dp_cmp_mismatch
  CPI 32
  JPZ dp_cmp_mismatch
  ; If different → mismatch
  LDA .char
  SUB .no_input
  JPZ dp_equal
  JMP dp_cmp_mismatch
dp_ct_zero:
  LDA .char
  CPI 0
  JPZ dp_match
  CPI 32
  JPZ dp_match
  JMP dp_cmp_mismatch
dp_equal:
  ; advance both
  LDA .pow2
  ADI 1
  STA .pow2
  LDA .res2
  ADI 1
  STA .res2
  ; dec counter
  LDA .num_digits
  SUI 1
  STA .num_digits
  JPZ dp_post8
  JMP dp_cmp_loop
dp_post8:
  ; after 8 chars, require name zero and input 0/space
  LDA .res2
  PHA
  LAS
  CPI 0
  JPZ dp_ct_zero2
  JMP dp_cmp_mismatch
dp_ct_zero2:
  LDA .pow2
  PHA
  LAS
  CPI 0
  JPZ dp_match
  CPI 32
  JPZ dp_match
  JMP dp_cmp_mismatch
dp_cmp_mismatch:
  ; advance to next entry: size 10
  LDA .arg2
  ADI 10
  STA .arg2
  JMP dp_entry
dp_match:
  ; Save entry base address for handler lookup (use work4 which build_argv won't clobber)
  LDA .arg2
  STA .work4
  ; Skip spaces to get args pointer into .arg1 (not used by launcher)
  LDA .pow2
  STA .arg1
  JSR skip_spaces
  ; Build argv at fixed memory block
  JSR build_argv
  ; Set handler ABI: .arg1 = argv_base, .arg2 = argv_buf
  LDI .argv_base
  STA .arg1
  LDI .argv_buf
  STA .arg2
  ; Read handler address at entry_base + 8
  LDA .work4
  ADI 8
  PHA
  LAS                   ; A = handler address
  STA .res2
  ; Patch call stub operand to handler address
  LDI 19801
  PHA
  LDA .res2
  SAS
  ; Call the stub to JSR handler and then RET back to OS
  JSR #19800
  LDI 1
  STA .res1
  RET
dp_nomatch:
  LDI 0
  STA .res1
  RET


; Build argc/argv from the raw argument string at .arg1
; Layout:
;  [argv_base+0] = argc
;  [argv_base+i] = pointer to argv[i-1] for i=1..argc
;  Arg strings copied into argv_buf, null-terminated
build_argv:
  ; argc = 0
  LDI .argv_base
  PHA
  LDI 0
  SAS
  ; work pointers
  LDI .argv_base
  ADI 1
  STA .work1         ; work1 = dest ptr slot (argv pointer array)
  LDI .argv_buf
  STA .work2         ; work2 = write pointer into buffer
  ; tp = .arg1
  LDA .arg1
  STA .work3
ba_next_token:
  ; skip spaces
  LDA .work3
  PHA
  LAS
  CPI 32
  JPZ ba_skip1
  CPI 0
  JPZ ba_done
  JMP ba_start
ba_skip1:
  LDA .work3
  ADI 1
  STA .work3
  JMP ba_next_token
ba_start:
  ; limit argc to 8
  LDI .argv_base
  PHA
  LAS
  CPI 8
  JPZ ba_done
  ; store pointer to current arg (work2) into argv array at work1
  LDA .work1
  PHA
  LDA .work2
  SAS
  ; copy token chars
ba_copy:
  LDA .work3
  PHA
  LAS
  CPI 0
  JPZ ba_term
  CPI 32
  JPZ ba_term
  ; write char to buffer
  STA .char
  LDA .work2
  PHA
  LDA .char
  SAS
  ; advance tp and buf
  LDA .work3
  ADI 1
  STA .work3
  LDA .work2
  ADI 1
  STA .work2
  JMP ba_copy
ba_term:
  ; null-terminate current token in buffer
  LDA .work2
  PHA
  LDI 0
  SAS
  ; advance buffer pointer past null
  LDA .work2
  ADI 1
  STA .work2
  ; argc++
  LDI .argv_base
  PHA
  LAS
  ADI 1
  STA .num_digits    ; reuse as tmp for new argc
  LDI .argv_base
  PHA
  LDA .num_digits
  SAS
  ; advance argv slot pointer
  LDA .work1
  ADI 1
  STA .work1
  ; continue with next token
  JMP ba_next_token
ba_done:
  RET
