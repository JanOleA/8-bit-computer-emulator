char = 4000                 ; variable for printing
textloc = 4001              ; location of next textline to print
arg1 = 4002                 ; argument 1 for subroutines
arg2 = 4003                 ; argument 2 for subroutines
res1 = 4004                 ; result 1 for subroutines
res2 = 4005                 ; result 2 for subroutines
pow2 = 4006                 ; special variable for divide routine
num_digits = 4007           ; number of digits to print in the display_number routine
ascii_start = 4008          ; location where ascii map starts
no_input = 4009             ; whether or not input has been reset

text = 4020     ; 16 bytes
text2 = 4036    ; 16 bytes
text_su = 4052  ; 12 bytes
space = 4064    ; 2 bytes
ascii_map = 4066 ; 56 bytes

.text     = "  EmuOS alpha  "
.text2    = "    Welcome!   "
.text_su  = "Starting..."
.space    = " "
.ascii_map = "0123456789 QWERTYUIOP ASDFGHJKL  ZXCVBNM,.             "
.ascii_start = 4066
; Map arithmetic keys to ASCII for the 32-bit keyboard:
; Key codes: 10:'/', 21:'*', 50:'+', 51:'-'
.ascii_map + 10 = "/"
.ascii_map + 21 = "*"
.ascii_map + 50 = "+"
.ascii_map + 51 = "-"

; --- Input buffering for command parsing ---
; Reserve a fixed input buffer BEFORE placing new variables.
; Buffer occupies addresses 4122..4201 inclusive (80 bytes)
input_buf = 4122            ; start of input buffer (80 bytes reserved)
input_ptr = 4202            ; current write pointer (address stored here)
cmd_len = 4203              ; current length of buffered input
cmd_ready = 4204            ; 1 when Enter pressed and buffer terminated

; ----- Call stub for returning external commands -----
; A small trampoline at a fixed address: [CALL_STUB]=JSR, [CALL_STUB+1]=handler addr (patched), [CALL_STUB+2]=RET
CALL_STUB = 49800
49800 = 16
49801 = 0
49802 = 17

; ----- argv/argv buffer reservation -----
argv_base = 4400            ; argv block base (argc + argv pointers)
argv_buf  = 4500            ; buffer where argument strings are copied
; Work registers for tokenizer
work1 = 4010
work2 = 4011
work3 = 4012
work4 = 4013         ; preserved entry base for handler lookup

; Program dispatch table (name[0..7], addr[8], reserved[9]) repeated; sentinel when name[0]==0
prog_table = 4300
; Command/program table entries: name[0..7], addr[8], reserved[9]
; Entry 0: MULTIPLY -> 50000
.prog_table       = "MULTIPLY"
.prog_table + 8   = 50000
.prog_table + 9   = 0
; Entry 1: DIVIDE   -> 50100
.prog_table + 10  = "DIVIDE"
.prog_table + 18  = 50100
.prog_table + 19  = 0
; Entry 2: DISPNUM  -> 50200 (display_number)
.prog_table + 20  = "DISPNUM"
.prog_table + 28  = 50200
.prog_table + 29  = 0
; Entry 3: LIST     -> 50300
.prog_table + 30  = "LIST"
.prog_table + 38  = 50300
.prog_table + 39  = 0
; Entry 4: PEEK     -> 50450
.prog_table + 40  = "PEEK"
.prog_table + 48  = 50450
.prog_table + 49  = 0
; Sentinel (name[0] == 0)
.prog_table + 50  = 0

start:
  JSR initialize_display
  LDI 4052
  STA .textloc
  JSR print
  JSR ret_home
  LDI 0           ; set variables to zero
  STA .char
  STA .arg1
  STA .arg2
  STA .res1
  STA .res2
  STA .pow2
  STA .num_digits
  STA .cmd_len
  STA .cmd_ready
  LDI .input_buf           ; initialize input pointer to start of buffer (numeric address)
  STA .input_ptr
  LDI 4020
  STA .textloc
  JSR print
  JSR newline
  LDI 4036
  STA .textloc
  JSR print
  JSR newline
  JSR newline
  JSR print_prompt    ; show prompt at start of input line
main_loop:
  JSR check_input
  LDA .res2
  CPI 0
  JPZ no_input
  LDA .no_input
  CPI 1
  JPZ main_loop 
  LDA .res1 
  CPI 31              ; Handle Enter key: trigger on key index 31 or 32
  JPZ handle_enter
  CPI 32
  JPZ handle_enter
  CPI 43              ; Backspace key
  JPZ handle_backspace
  LDA .ascii_start
  ADD .res1
  PHA
  LAS
  STA .char
  JSR write_char
  ; Store typed char into input buffer at [.input_ptr]
  LDA .input_ptr           ; push destination address
  PHA
  LDA .char                ; value to store in A
  SAS                      ; store A at address popped from stack

  ; Advance pointer and update length (clamped)
  LDA .input_ptr
  ADI 1
  STA .input_ptr
  ; Clamp pointer to end of buffer (end = 4202); if equal, move back one
  CPI 4202
  JPZ clamp_ptr
  JMP after_ptr
clamp_ptr:
  LDA .input_ptr
  SUI 1
  STA .input_ptr
after_ptr:
  LDA .cmd_len
  ADI 1
  STA .cmd_len
  ; Clamp length to max buffer size (80); if equal, move back one
  CPI 80
  JPZ clamp_len
  JMP after_len
clamp_len:
  LDA .cmd_len
  SUI 1
  STA .cmd_len
after_len:
  LDI 1
  STA .no_input
  JMP main_loop

handle_backspace:
  ; If at buffer start, do nothing
  LDA .input_ptr
  CPI .input_buf
  JPZ hb_done
  ; Move input pointer back by one
  LDA .input_ptr
  SUI 1
  STA .input_ptr
  ; Clear character in buffer (write 0 at new pointer)
  LDA .input_ptr
  PHA
  LDI 0
  SAS
  ; Decrement length if > 0
  LDA .cmd_len
  CPI 0
  JPZ hb_after_len
  SUI 1
  STA .cmd_len
hb_after_len:
  ; Visually erase last character on the display
  JSR cursor_left
  LDI 32            ; write space
  STA .char
  JSR write_char
  JSR cursor_left
hb_done:
  LDI 1
  STA .no_input
  JMP main_loop

handle_enter:         ; Finalize buffer, echo command, prepare for next input
  ; Terminate buffer with null (0), set ready flag
  LDA .input_ptr      ; push current pointer address
  PHA
  LDI 0
  SAS                 ; write 0-terminator
  LDI 1
  STA .cmd_ready

  ; Move cursor visually to next line start
  JSR enter

  ; Dispatch the typed command
  JSR run_command

  ; Reset input pointer/length for next command
  LDI .input_buf
  STA .input_ptr
  LDI 0
  STA .cmd_len
  ; Print prompt for next command line
  JSR print_prompt
  LDI 1
  STA .no_input
  JMP main_loop

no_input:
  LDI 0
  STA .no_input
  JMP main_loop

check_input:        ; check for input
  KEI
  PHA               ; push input to stack
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  RSA
  CPI 1             ; compare top bit to 1
  JPZ input_entered
  PLA
  LDI 0
  STA .res2
  RET
input_entered:
  PLA
  SUI 128
  OUT
  STA .res1
  LDI 1
  STA .res2
  RET

initialize_display: ; initializes the display
  DIS 1             ; 0000 0001 - clear display
  JSR instruction
  DIS 6             ; 0000 0110 - Set entry mode, cursor direction to increment
  JSR instruction 
  DIS 15            ; set on, display cursor, cursor blink
  JSR instruction
  RET

print:              ; gets the first memory address for a string from .textloc and prints it to console (null terminated)
  JSR get_next_char
  CPI 0
  JPZ end_print
  JSR write_char
  JMP print
end_print:
  RET

get_next_char:      ; gets the next character from .textloc and increases .textloc by 1
  LDA .textloc
  PHA
  ADI 1
  STA .textloc
  LAS               ; get the value from .textloc into A
  STA .char
  RET

write_char:         ; write the character in .char to screen
  LDD .char
  DIC 0
  DIC 64            ; set read
  DIC 192           ; set read + enable
  DIC 0
  RET

newline:            ; print newline on the screen
  DIS 32            ; data for newline
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

ret_home:           ; return to home (first column) on current line on screen
  JSR newline
  DIS 24            ; data for cursor up
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

instruction:        ; screen instruction
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

print_prompt:
  LDI 62            ; '>'
  STA .char
  JSR write_char
  LDI 32            ; space
  STA .char
  JSR write_char
  RET

cursor_left:        ; move cursor one position left on the display
  DIS 18            ; cursor left control
  DIC 0
  DIC 128           ; set enable
  DIC 0
  RET

enter:              ; go to first character on the next line
  JSR ret_home      ; ret_home puts cursor at column 0 on current line
  JSR newline       ; newline moves to next line keeping column -> now at column 0 on next line
  RET


; --------------
; Command parsing
; --------------

run_command:
  ; Set pointer to start of input buffer
  LDI .input_buf
  STA .arg1
  JSR skip_spaces

  ; First try dispatch table
  JSR dispatch_program
  ; If .res1 == 1, program was launched
  LDA .res1
  CPI 1
  JPZ rc_done

rc_run_fallback:
  ; Fallback: RUN <addr>
  ; Check token "RUN"
  LDA .arg1
  PHA
  LAS
  CPI 82            ; 'R'
  JPZ rc_ch1
  RET               ; unknown command → ignore
rc_ch1:
  LDA .arg1
  ADI 1
  PHA
  LAS
  CPI 85            ; 'U'
  JPZ rc_ch2
  RET
rc_ch2:
  LDA .arg1
  ADI 2
  PHA
  LAS
  CPI 78            ; 'N'
  JPZ rc_delim
  RET
rc_delim:
  LDA .arg1
  ADI 3
  STA .arg1
  ; parse decimal address
  JSR parse_number
  ; push target address and RET to jump
  LDA .res1
  PHA
  RET

rc_done:
  RET

; Skip spaces at .arg1
skip_spaces:
  LDA .arg1
  PHA
  LAS
  CPI 32
  JPZ sksp_inc
  RET
sksp_inc:
  LDA .arg1
  ADI 1
  STA .arg1
  JMP skip_spaces

; Parse a decimal number at .arg1 into .res1 and advance .arg1
parse_number:
  LDI 0
  STA .res1
  JSR skip_spaces
pn_loop:
  LDA .arg1
  PHA
  LAS                 ; A = current char
  CPI 48              ; if A < '0' -> done
  JPC pn_check_hi
  JMP pn_done
pn_check_hi:
  CPI 58              ; if A >= ':' -> done
  JPC pn_done
  ; convert to digit
  SUI 48
  STA .char
  ; res1 = res1*10
  LDA .res1
  LSA
  STA .pow2           ; reuse as tmp = res*2
  LSA
  LSA                 ; A = res*8
  ADD .pow2           ; A = res*10
  STA .res1
  ; res1 += digit
  LDA .res1
  ADD .char
  STA .res1
  ; advance pointer
  LDA .arg1
  ADI 1
  STA .arg1
  JMP pn_loop
pn_done:
  RET

; Dispatches a program by token using the table at .prog_table
; On success: launches program (RET into its address); On no match: sets .res1=0 and returns
dispatch_program:
  LDI 0
  STA .res1
  ; token start in .arg1
  LDA .arg1
  STA .textloc         ; reuse as token pointer (tp)
  ; table pointer in .arg2
  LDI .prog_table
  STA .arg2

dp_entry:
  ; Check sentinel: if name[0] == 0 → no match
  LDA .arg2
  PHA
  LAS
  CPI 0
  JPZ dp_nomatch
  ; Compare up to 8 chars
  LDA .arg2
  STA .res2            ; res2 = name ptr
  LDA .textloc
  STA .pow2            ; pow2 = tp (input)
  LDI 8
  STA .num_digits      ; use as counter
dp_cmp_loop:
  ; load input char
  LDA .pow2
  PHA
  LAS
  STA .char
  ; load name char
  LDA .res2
  PHA
  LAS
  STA .no_input        ; use as temp
  ; If name char == 0 and input is 0 or space → match
  LDA .no_input
  CPI 0
  JPZ dp_ct_zero
  ; If input is 0/space and name not zero → mismatch
  LDA .char
  CPI 0
  JPZ dp_cmp_mismatch
  CPI 32
  JPZ dp_cmp_mismatch
  ; If different → mismatch
  LDA .char
  SUB .no_input
  JPZ dp_equal
  JMP dp_cmp_mismatch
dp_ct_zero:
  LDA .char
  CPI 0
  JPZ dp_match
  CPI 32
  JPZ dp_match
  JMP dp_cmp_mismatch
dp_equal:
  ; advance both
  LDA .pow2
  ADI 1
  STA .pow2
  LDA .res2
  ADI 1
  STA .res2
  ; dec counter
  LDA .num_digits
  SUI 1
  STA .num_digits
  JPZ dp_post8
  JMP dp_cmp_loop
dp_post8:
  ; after 8 chars, require name zero and input 0/space
  LDA .res2
  PHA
  LAS
  CPI 0
  JPZ dp_ct_zero2
  JMP dp_cmp_mismatch
dp_ct_zero2:
  LDA .pow2
  PHA
  LAS
  CPI 0
  JPZ dp_match
  CPI 32
  JPZ dp_match
  JMP dp_cmp_mismatch
dp_cmp_mismatch:
  ; advance to next entry: size 10
  LDA .arg2
  ADI 10
  STA .arg2
  JMP dp_entry
dp_match:
  ; Save entry base address for handler lookup (use work4 which build_argv won't clobber)
  LDA .arg2
  STA .work4
  ; Skip spaces to get args pointer into .arg1 (not used by launcher)
  LDA .pow2
  STA .arg1
  JSR skip_spaces
  ; Build argv at fixed memory block
  JSR build_argv
  ; Set handler ABI: .arg1 = argv_base, .arg2 = argv_buf
  LDI .argv_base
  STA .arg1
  LDI .argv_buf
  STA .arg2
  ; Read handler address at entry_base + 8
  LDA .work4
  ADI 8
  PHA
  LAS                   ; A = handler address
  STA .res2
  ; Patch call stub operand to handler address
  LDI 49801
  PHA
  LDA .res2
  SAS
  ; Call the stub to JSR handler and then RET back to OS
  JSR #49800
  LDI 1
  STA .res1
  RET
dp_nomatch:
  LDI 0
  STA .res1
  RET


; Build argc/argv from the raw argument string at .arg1
; Layout:
;  [argv_base+0] = argc
;  [argv_base+i] = pointer to argv[i-1] for i=1..argc
;  Arg strings copied into argv_buf, null-terminated
build_argv:
  ; argc = 0
  LDI .argv_base
  PHA
  LDI 0
  SAS
  ; work pointers
  LDI .argv_base
  ADI 1
  STA .work1         ; work1 = dest ptr slot (argv pointer array)
  LDI .argv_buf
  STA .work2         ; work2 = write pointer into buffer
  ; tp = .arg1
  LDA .arg1
  STA .work3
ba_next_token:
  ; skip spaces
  LDA .work3
  PHA
  LAS
  CPI 32
  JPZ ba_skip1
  CPI 0
  JPZ ba_done
  JMP ba_start
ba_skip1:
  LDA .work3
  ADI 1
  STA .work3
  JMP ba_next_token
ba_start:
  ; limit argc to 8
  LDI .argv_base
  PHA
  LAS
  CPI 8
  JPZ ba_done
  ; store pointer to current arg (work2) into argv array at work1
  LDA .work1
  PHA
  LDA .work2
  SAS
  ; copy token chars
ba_copy:
  LDA .work3
  PHA
  LAS
  CPI 0
  JPZ ba_term
  CPI 32
  JPZ ba_term
  ; write char to buffer
  STA .char
  LDA .work2
  PHA
  LDA .char
  SAS
  ; advance tp and buf
  LDA .work3
  ADI 1
  STA .work3
  LDA .work2
  ADI 1
  STA .work2
  JMP ba_copy
ba_term:
  ; null-terminate current token in buffer
  LDA .work2
  PHA
  LDI 0
  SAS
  ; advance buffer pointer past null
  LDA .work2
  ADI 1
  STA .work2
  ; argc++
  LDI .argv_base
  PHA
  LAS
  ADI 1
  STA .num_digits    ; reuse as tmp for new argc
  LDI .argv_base
  PHA
  LDA .num_digits
  SAS
  ; advance argv slot pointer
  LDA .work1
  ADI 1
  STA .work1
  ; continue with next token
  JMP ba_next_token
ba_done:
  RET
